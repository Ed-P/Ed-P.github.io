<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>IoU</title>
    <url>/2021/11/10/IoU/</url>
    <content><![CDATA[<h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro."></a>Intro.</h3><p>IoU, Intersection over Union, can be used as a similarity measure for object detection on images. (It is also called Jaccard index since it is developed by Paul Jaccard) </p>
<span id="more"></span>

<p>It’s formula is:<br>$$<br>IoU(A,B)= \frac{|A\cap B|}{|A\cup B|}<br>$$<br>In object detection, the two inputs of IoU should be the testing box and the ground truth box. IoU is scale invariant, which means it does not care about the size of the box.</p>
<h3 id="Code-Python"><a href="#Code-Python" class="headerlink" title="Code (Python)"></a>Code (Python)</h3><p>First we consider a 1-D case, where we have two line segments in the real number set (R). One is from x1 to x2, another is from y1 to y2. For the Union set, you can use what you have learned in your probability course, union(A,B) = A + B - inter(A,B). So our core problem is to compute the intersection set. </p>
<p>If these tow line segments are intersected, we must have y1&gt;x2 and x1&gt;y2, or they do not have intersection and |A∩B|=0. And what we need is to find the upper and lower bound of A∩B, we can also use the ub and lb to find if they are intersected:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">iou</span>(<span class="params">A,B</span>):</span></span><br><span class="line">    </span><br><span class="line">    x1,x2 = A</span><br><span class="line">    y1,y2 = B</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># find the upper and lower bound</span></span><br><span class="line">    hb = <span class="built_in">min</span>(x2,y2)</span><br><span class="line">    lb = <span class="built_in">max</span>(x1,y1)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># compute intersection</span></span><br><span class="line">    <span class="keyword">if</span> hb&lt;lb:</span><br><span class="line">        inter = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        inter = hb - lb</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># union</span></span><br><span class="line">    </span><br><span class="line">    union = (x2 - x1) + (y2 - y1) - inter</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> inter / union</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>For 2-D case, there are two boxes and we want to find their intersection as well, which is also a box. However, there is no need to find all the vertex of the intersection box, since we only want the area size. Hence we choose to compute the width and height of the box:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">iou</span>(<span class="params">A,B</span>):</span></span><br><span class="line">    <span class="comment"># here we defaultly define A and B as lists: A=[x-coordinate1, x-coordinate2, y-coordinate1, y-coordinate2]</span></span><br><span class="line">    <span class="comment"># define the left top as original point, i.e. (0,0)</span></span><br><span class="line">    </span><br><span class="line">    in_w = <span class="built_in">min</span>(A[<span class="number">1</span>],B[<span class="number">1</span>])-<span class="built_in">max</span>(A[<span class="number">0</span>],B[<span class="number">0</span>])</span><br><span class="line">    in_h = <span class="built_in">min</span>(A[<span class="number">3</span>],B[<span class="number">3</span>])-<span class="built_in">max</span>(A[<span class="number">2</span>],B[<span class="number">2</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#compute intersection</span></span><br><span class="line">    inter = <span class="number">0</span> <span class="keyword">if</span> in_w&lt;<span class="number">0</span> <span class="keyword">or</span> in_h&lt;<span class="number">0</span> <span class="keyword">else</span> in_w*in_h</span><br><span class="line"></span><br><span class="line">    <span class="comment">#compute union</span></span><br><span class="line">    union = (A[<span class="number">1</span>]-A[<span class="number">0</span>])*(A[<span class="number">3</span>]-A[<span class="number">2</span>]) + (B[<span class="number">1</span>]-B[<span class="number">0</span>])*(B[<span class="number">3</span>]-B[<span class="number">2</span>]) - inter</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> inter / union</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>Knowledge</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>object_detection</tag>
      </tags>
  </entry>
  <entry>
    <title>Knowledge_Distillation</title>
    <url>/2021/12/12/Knowledge-Distillation/</url>
    <content><![CDATA[<p>An introduction and summary of KD(knowledge distillation) methods.</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>Knowledge</category>
      </categories>
      <tags>
        <tag>Efficient_Neural_Network</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux服务器搭建</title>
    <url>/2021/10/16/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>这里上传一些当时搭服务器的技巧吧 也算是备忘录</p>
<p>##传文件</p>
<p>###1.传文件到服务器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ scp /path/file（这部分为本地的路径） user（远端目标用户名）@host（远端目标IP）:/home/username（文件存储路径）</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>###2.从服务器下载文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ scp user（远端用户名）@host（远端IP）:/path/file（下载文件在远端的路径） localpathorfile（本地文件存放路径）</span><br></pre></td></tr></table></figure>

<p>##安装anaconda</p>
<p>###1.下载</p>
<p>清华源(一般在内地因为下外网的东西比较麻烦，转到清华源下会比较好)：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/?C=M&amp;O=A</span><br></pre></td></tr></table></figure>
<p>传到服务器上：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ scp Anaconda3-2019.10-Linux-x86_64.sh username@远程服务器IP:/home/username</span><br></pre></td></tr></table></figure>

<p>###2.安装</p>
<p>在服务器文件夹下：</p>
<p>用bash命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ bash Anaconda3-2019.10-Linux-x86_64.sh</span><br></pre></td></tr></table></figure>
<p> 连续（enter，yes，yes）</p>
<p>##conda常用的命令</p>
<pre><code>1）conda list 查看安装了哪些包。

2）conda env list 或 conda info -e 查看当前存在哪些虚拟环境

3）conda update conda 检查更新当前conda

4）conda --version 查询conda版本 （在环境里打开命令行输入python --version可以检查当前python的版本）

5）conda -h 查询conda的命令使用
</code></pre>
<p>创建python虚拟环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ conda create -n your_env_name python=X.X</span><br></pre></td></tr></table></figure>

<p>激活(或切换不同python版本)的虚拟环境<br>Linux: </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">source</span> activate your_env_name(虚拟环境名称)</span><br></pre></td></tr></table></figure>

<p>Windows: </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ activate your_env_name(虚拟环境名称) (conda activate)</span><br></pre></td></tr></table></figure>
<p>(这里我一般用conda activate 就好了)</p>
<p>关闭虚拟环境<br>Linux: </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">source</span> deactivate</span><br></pre></td></tr></table></figure>

<p>Windows: </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ deactivate （conda deactivate）</span><br></pre></td></tr></table></figure>

<p>删除虚拟环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ conda remove -n your_env_name(虚拟环境名称) --all</span><br></pre></td></tr></table></figure>
<p>##用Xshell远程连接服务器上的jupyter notebook</p>
<p>这个我觉得比较重要，至少方便做一些可视化的事情，然后传输文件也很方便</p>
<p>###（1）生成config文件<br>    在环境里输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ jupyter notebook --generate-config</span><br></pre></td></tr></table></figure>
<p>###（2）生成密码<br>    打开python：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ from notebook.auth import passwd</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ passwd()</span><br></pre></td></tr></table></figure>
<pre><code>#输入两次密码
#Enter password: 
#Verify password: 
#然后出现
#&#39;sha1:xxxxxxxxxxxxxxxxx&#39;
</code></pre>
<p>###（3）修改config文件<br>    进入config文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vim ~/.jupyter/jupyter_notebook_config.py</span><br></pre></td></tr></table></figure>
<pre><code>找空位按i然后直接粘贴：
</code></pre>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ c.NotebookApp.ip=<span class="string">&#x27;*&#x27;</span></span><br><span class="line">$ c.NotebookApp.password = u<span class="string">&#x27;sha1:xxxxxx&#x27;</span><span class="comment">#刚才复制的</span></span><br><span class="line">$ c.NotebookApp.open_browser = False</span><br><span class="line">$ c.NotebookApp.port =7548 <span class="comment">#随便指定一个目标端口</span></span><br></pre></td></tr></table></figure>
<pre><code>退出vim：
先按esc退出编辑状态
然后打出：
输入wq
enter即可
</code></pre>
<p>###（4）修改x-shell的channel<br>    在服务器的属性的隧道里</p>
<pre><code>添加
本地（拨出）
localhost
1234（某侦听端口数字）
x仅限本地连接
localhost
7548（某目标端口）
</code></pre>
<p>###（5）运行jupyter notebook<br>    linux上输入：<br>    jupyter notebook<br>    然后在本地浏览器输入127.0.0.1:1234，1234是上一步设置的侦听端口<br>    再在打开的界面输入密码就OK了</p>
<p><img src="R.jpg" alt="R"></p>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>skill</tag>
      </tags>
  </entry>
  <entry>
    <title>Mean Average Precision（MAP)</title>
    <url>/2021/11/25/Mean-Average-Precision%EF%BC%88MAP%EF%BC%89/</url>
    <content><![CDATA[<h3 id="Precision-amp-Recall"><a href="#Precision-amp-Recall" class="headerlink" title="Precision&amp;Recall"></a>Precision&amp;Recall</h3><p>The formula of precision and recall is:</p>
<span id="more"></span>

<p><img src="equation.svg" alt="equation"></p>
<p><img src="equation2.svg" alt="equation2"></p>
<p>Precision is used to evaluate the accuracy of test result, which is actually the proportion of  true tested result in the total result.</p>
<p>Recall is used to evaluate the quality of the test result, which is actually the proportion of the true tested result in the total true result, that is , including the true tested result and the true non-tested result.</p>
<h4 id="TP-TN-FP-FN"><a href="#TP-TN-FP-FN" class="headerlink" title="TP, TN, FP, FN"></a>TP, TN, FP, FN</h4><p>To have a better understanding of precision and recall, we should know the definition of TP, TN, FP and FN.</p>
<p><img src="v2-761706f5b1fe36873ba1bb20c7d1d447_720w.jpg" alt="v2-761706f5b1fe36873ba1bb20c7d1d447_720w"></p>
<p>As the graph indicated, all the data is first divided into two part: positive and negative. They  are the annotation that pre-labeled to the data, or you can say it is the ‘ground truth’.</p>
<p>Then after testing, we have another set that is  tested by the algorithm, which is the data that the testing algorithm/model thinks positive. It also contains two parts:  1. the algorithm tests right, the data that is indeed positive. 2. the algorithm tests wrong, the data that is actually negative. These two part is just TP and FP, respectively.</p>
<p>There remains two parts in the data that the algorithm doesn’t think positive: 1, the data is positive but is not tested positive. 2. the data is negative but is not tested positive too. They are FN and TN.</p>
<p>A short summarization:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TP: true positive, the data is ground-truth positive and is also tested as positive.</span><br><span class="line">TN: true negative, the data is ground-truth negative and is not tested as positive.</span><br><span class="line">FP: false positive, the data is ground-truth negative but is tested as positive.</span><br><span class="line">FN: false negative, the data is ground-truth positive but is tested as negative.</span><br></pre></td></tr></table></figure>

<p>You may be reminded that the words true/false is adjective.</p>
<h3 id="Labeling-based-on-IoU"><a href="#Labeling-based-on-IoU" class="headerlink" title="Labeling based on IoU"></a>Labeling based on IoU</h3><p>We know that the testing in detection is in the form of outputting <strong>bounding box</strong>, and it is impossible or hard to make the testing box and the ground-truth box to be exactly the same, hence we need the method of IoU to construct labeling, including the labeling of TP, FP, FN. Note that since in detection we do not care about the background, the definition of TN will not be specialized. About IoU, you may see my blog [here](<a href="http://edwardpei.com/2021/11/10/IoU/#more">IoU | 流千过客-Ed-P (edwardpei.com)</a>).  The output of the algorithm is always based on the IoU score, so we should define a threshold to control the output, i.e. IoU_threshold = 0.5. </p>
<h4 id="Confidence"><a href="#Confidence" class="headerlink" title="Confidence"></a>Confidence</h4><p>Before I give the details, we should know the definition of ‘confidence’.  Confidence is a quality that measured whether a bounding box containing the gt object and the accuracy of the bounding box.</p>
<p>In YOLO, confidence is defined as:</p>
<p><img src="8904720-5bda664f53501a53.webp" alt="8904720-5bda664f53501a53"></p>
<p>When the center of the gt is contained in the bounding box, Pr(Object) is 1, or it is 0.</p>
<p>By using confidence, we can compare the bounding boxes for the same gt. It should be noted that in order to make the labeling result to be reasonable, we should count the TP for each gt just once. That is,  we may have the probability that there are lots of bounding box have IoU score exceed the threshold. In this case, we only take the bounding box that has the highest confidence (just highest IoU), which is just TP and then other boxes are labeled as FP. So in this way, you should understanding why we just count once for each gt, since if take all the box exceed the threshold as TP, there will have problems: 1. the precision is too cheap,  then the precision will very high, then it will lose the authority of measuring the accuracy. 2. the precision may be imbalanced, consider when one gt has many box satisfied the requirement but another gt just have few boxes satisfied the requirement, then the precision will still be high.</p>
<p>Then we labeling the boxes that have IoU score lower than threshold with corresponding gt as FP,  which is the data that algorithm tests wrong. And FN is the number of gt box that is not be detected in testing.</p>
<h3 id="Average-Precision-AP"><a href="#Average-Precision-AP" class="headerlink" title="Average Precision (AP)"></a>Average Precision (AP)</h3><h4 id="PR-curve"><a href="#PR-curve" class="headerlink" title="PR-curve"></a>PR-curve</h4><p>We have know the definition of precision and recall, then we can make a table as following, assuming that there are 5 objects in an image and a model generates 10 boxes and these boxes are ranked according to their confidence scores.</p>
<p><img src="image-20211125173345116.png" alt="image-20211125173345116"></p>
<p>Based on this table, we can draw the PR-curve, as the recall increase the precision will decrease gradually(but not absolutely):</p>
<p><img src="image-20211125174044663.png" alt="image-20211125174044663"></p>
<p>Average Precision is just to calculate the average for the precision scores on the PR-curve. It can be calculated by integration since the recall scores vary from 0 to 1:</p>
<p><img src="equation(1).svg" alt="equation(1)"></p>
<p>However,  we always first smooth the PR-curve before calculating the AP: </p>
<p><img src="image-20211125181518876.png" alt="image-20211125181518876"></p>
<p><img src="equation(2).svg" alt="equation(2)"></p>
<p>There are variant methods to calculate AP in the history.</p>
<h4 id="Interpolated-AP-Before-VOC2010"><a href="#Interpolated-AP-Before-VOC2010" class="headerlink" title="Interpolated AP (Before VOC2010 )"></a>Interpolated AP (Before VOC2010 )</h4><p>On the smooth PR-curve, taking 10 equal diversion points from 0 to 1 (totally 11 points), then calculate the average of their precision score:</p>
<p><img src="equation(3).svg" alt="equation(3)"></p>
<p><img src="image-20211125182736420.png" alt="image-20211125182736420"></p>
<h4 id="Area-under-curve-After-VOC2010"><a href="#Area-under-curve-After-VOC2010" class="headerlink" title="Area under curve(After VOC2010)"></a>Area under curve(After VOC2010)</h4><p>For the previous interpolated AP, there may be some errors in the sample points. The method with more accuracy is to calculate the integration on smooth PR-curve.</p>
<h4 id="COCO-mAP"><a href="#COCO-mAP" class="headerlink" title="COCO mAP"></a>COCO mAP</h4><p>In order to increase the accuracy, COCO taking 100 points to calculate AP. What’s more, the threshold of IoU is taking from 0.5 to 0.95 with a step size of 0.05, then the mAP for a category is the average AP for these different IoU. It is noted as AP[.5 : .95].</p>
<p><img src="image-20211125184428026.png" alt="image-20211125184428026"></p>
<p>(you can also calculate Average recall(AR) similarly)</p>
<h3 id="MAP"><a href="#MAP" class="headerlink" title="MAP"></a>MAP</h3><p>MAP, mean average precision, is the mean of AP for all the categories. For example, in an image we have 10 detections with 2 categories. Calculating the AP for each category and take the mean finally.</p>
]]></content>
      <categories>
        <category>Knowledge</category>
      </categories>
      <tags>
        <tag>Object_Detection</tag>
      </tags>
  </entry>
  <entry>
    <title>Quantization</title>
    <url>/2021/12/12/Quantization/</url>
    <content><![CDATA[<p>An introduction and summary of quantization methods. </p>
<span id="more"></span>

<p>I will rewrite it by LaTeX if necessary for better reading.</p>
<h2 id="Preliminary"><a href="#Preliminary" class="headerlink" title="Preliminary"></a>Preliminary</h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro."></a>Intro.</h3><p>What does quantization mean? Efficient? How can it work?</p>
<p>In Wikipedia, they define quantization as: “Quantization, in mathematics and digital signal processing, is the process of mapping input values from a large set (often a continuous set) to output values in a (countable) smaller set, often with a finite number of elements.”  It’s trivial that we need precise numbers during computation to obtain precise results. A precise number is always the values in the real number set, which is actually a large set. </p>
<p>However, using more precise numbers means that you needs more memory to store it (it’s the same in the real world, imaging that you are struggling to remember some specific things, such as <em>π</em> ). So, reducing the precision to remember something easily is natural. And that is what quantization does. For computer, it is not different, and it may be more clear to see why. The goal of quantization is to reduce the precision of the parameters (weights, bias) and the intermediate activations to low-precision.</p>
<h3 id="Binary-system"><a href="#Binary-system" class="headerlink" title="Binary system"></a>Binary system</h3><p>We use decimal system in our daily life, with 10 numbers and can write any number in powers of 10:</p>
<p><img src="nanotes2021students.pdf.png" alt="nanotes2021students.pdf"></p>
<p>Computers work internally in the binary system with only two digits 0 and 1, the real number 9.90625 can be written as:</p>
<p><img src="nanotes2021students1.pdf.png" alt="nanotes2021students1.pdf"></p>
<h4 id="Normalized-scientific-notation-and-floating-point-representation"><a href="#Normalized-scientific-notation-and-floating-point-representation" class="headerlink" title="Normalized scientific notation and floating-point  representation"></a>Normalized scientific notation and floating-point  representation</h4><p>In decimal system, we express any real number in normalized scientific notation:</p>
<p><img src="image-20211213104448578.png" alt="image-20211213104448578"></p>
<p>where r is a real number in the range 0.1 &lt;= r &lt; 1 and n is an integer.</p>
<p>The real number in the form 0.0025 is called a fixed-point number, and its floating-point representation is 0.259*10^{-2} (just the normalized scientific notation). </p>
<p>Since computers can only operate using real numbers expressed in a <strong>fixed</strong> number of digits (depending on their word length), by using the floating-point representation we can express the numbers in a larger range. For example, with a fixed 8 digits, one can only express the real number in fixed-point form from 0.0000001 (10^-7) to 9.9999999 (≈10). However, in the floating-point representation the range is from 10^-99 to 10^99 if we use 2 of the digits to represent a power if 10. But at what cost? The accuracy of the numbers of floating-point representation will be relatively lower (it is similar to our main topic quantization).</p>
<p>In binary system, we have similar representation:</p>
<p><img src="image-20211213110511521.png" alt="image-20211213110511521"></p>
<p>where 1*2^-1 &lt;= q &lt; 1( 1/2,1) and m is an integer. q is called the mantissa and m is called the exponent and they are both in the binary form. Actually, m decides the movement of the binary point in q. For example, if m equals to 4 (in binary form 100), we may shift  the binary point 4 places to the right.</p>
<p>Since the first nonzero bit must be 1 in the mantissa, we can express q as (1.f)_2 and hence the first bit does need to store.</p>
<p>The accuracy of a number represented by a computer depends on the word length of the computer, such as 32 bits, 64 bits. The word length is divided into three section in the floating-point representation (here use 32 bits as example): 1. one bit for the sign if q; 2. 8 bits for m (there also contains 1 bit for m’s sign); 3. 23 bits for q.</p>
<p>(FP16: 1: sign, 5: m, 10: q.) </p>
<p>(FP32: Single-precision floating-point format; FP16: Half-precision floating-point format)</p>
<p>It has the following form:</p>
<p><img src="image-20211213112908737.png" alt="image-20211213112908737"></p>
<p>where</p>
<p><img src="image-20211213112930698.png" alt="image-20211213112930698"></p>
<p>and</p>
<p><img src="image-20211213113033704.png" alt="image-20211213113033704"></p>
<p>Noting that m has 7 digits in binary, so the largest m is 127. Hence a computer with word length 32 bits can handle numbers as small as (1.f * 2^-m) and as large as (1.f * 2^m). (Can not be used directly, the range of m has some trick, you can see in the next section)</p>
<h4 id="Integer-in-binary"><a href="#Integer-in-binary" class="headerlink" title="Integer in binary"></a>Integer in binary</h4><p><strong>int8</strong>: using 1 byte (8 bits) to express the integer with sign.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The first bit is used to express the sign, 1-negative; 0-positive.</span><br><span class="line"></span><br><span class="line">The largest value in the binary form:</span><br><span class="line">0 1 1 1 1 1 1 1</span><br><span class="line"></span><br><span class="line">In decimal form:</span><br><span class="line">0       1       1       1       1       1       1       1</span><br><span class="line">0*2^7 + 1*2^6 + 1*2^5 + 1*2^4 + 1*2^3 + 1*2^2 + 1*2^1 + 1*2^0</span><br><span class="line">0     + 64    + 32    + 16    + 8     + 4     + 2     + 1</span><br><span class="line">= 127</span><br><span class="line"></span><br><span class="line">The smallest value:</span><br><span class="line">1 0 0 0 0 0 0 0</span><br><span class="line"></span><br><span class="line">In decimal form:</span><br><span class="line"> 1       0       0       0       0       0       0       0</span><br><span class="line">-1*2^7 + 0*2^6 + 0*2^5 + 0*2^4 + 0*2^3 + 0*2^2 + 0*2^1 + 0*2^0</span><br><span class="line">-128   + 0     + 0     + 0     + 0     + 0     + 0     + 0</span><br><span class="line"> = -128</span><br></pre></td></tr></table></figure>

<p><strong>uint8</strong>: using 1 byte (8 bits) to express the integer without sign.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2^8-1 = 256-1 = 255</span><br><span class="line">since 0 occupies one position.</span><br><span class="line">0~255</span><br></pre></td></tr></table></figure>

<h3 id="Why-quantization"><a href="#Why-quantization" class="headerlink" title="Why quantization?"></a>Why quantization?</h3><p>So, quantization is just to transfer the values (weights, bias, activations) stored in the floating-point form in 32FP to the data type int8/unit8. (8/4/2/1 bit quantization, 8 bit is the most common one.) </p>
<p>When we apply quantization into a deep learning model</p>
<ol>
<li>More efficient computation. It is more efficient for many processors to handle integer calculation than corresponding floating -point calculations (Why?). On CPU, the latency of floating-point calculation command is averagely longer than the corresponding integer calculation command. </li>
<li>Reduce memory footprint and storage footprint. Reduce the time cost in memory access. For FP32, each weight/bias need 32-bit storage, and it will become 8-bit after quantization. </li>
<li>(Reduce the energy consumption)</li>
</ol>
<p><img src="image-20211215141117555.png" alt="image-20211215141117555"></p>
<h3 id="Inference-and-Training"><a href="#Inference-and-Training" class="headerlink" title="Inference and Training"></a>Inference and Training</h3><p>Although quantization can achieve good result in reducing the network computation, we still need complex and high-accuracy model in training to capture the slight gradient change. It’s a trade-off between the precision and efficiency. </p>
<p>Therefore, most of the time, we apply quantization on the trained neural network, which has become convergence. Then the precision will be maintained in best possible after quantization. This is the quantization on inference.</p>
<p>When applying quantization in running inference, we have PTQ and QAT approaches, which will be discussed later. </p>
<p>In fact, it’s not like we don’t use quantization in training of neural networks. QAT uses some techniques to recover the accuracy of models by re-training the networks with quantized parameters.</p>
<p>There also are algorithms focus on training the models on quantization from the very beginning. It seems to pay attention to better gradient quantization. </p>
<h2 id="Basic-Definition"><a href="#Basic-Definition" class="headerlink" title="Basic Definition"></a>Basic Definition</h2><p>The process of quantization is actually a rounding or truncation problem. There is a general function that maps real values in floating point to a lower precision range:</p>
<p><img src="image-20211213174837627.png" alt="image-20211213174837627"></p>
<p>where x is a real value input (weight, bias, activation), q is the value after quantization, s is called scaling factor, z is called the zero point. s may be variable in different methods, which will be discussed later(calibration). z can be used to adjust the true zero in some asymmetrical quantization approaches.</p>
<p>(activation is the output of the activation function of each layer)</p>
<p>For the rounding function, it is always the same as the round function in python, that is four dropping and five filling in Chinese **(**not exactly, the first reason is that the rounding function varies with the version of python: py2: “Values are rounded to the closest multiple of 10 to the power minus n digits; if two multiples are equally close, rounding is done away from 0.” py3: “values are rounded to the closest multiple of 10 to the power minus n digits; if two multiples are equally close, rounding is done toward the even choice.” The second reason is that the rounding is influenced by the rounding errors of computer because of the world length limitation. Hence, you may use the functions in math or decimal modules of python. <strong>)</strong>. Sometimes researchers use the int() function in python, that is remaining the integer part regardless of the value after the decimal point. </p>
<p>Noting that here z is set inside the rounding function, but there also are some algorithms set z outside the rounding function. They are different in the searching domain of  z, the former is in real numbers domain and the latter is in the lower precision domain. The consequence is that (you can prove it by using mathematics by yourself) the domain of real values that will be quantized into zero-point will be different (yes, it is a multiple to 1 mapping): If you set it before rounding, then you can choose a specific real number and the values around it (the range depends on s) to be quantized into 0. If you set it after rounding, the you can choose a value in the lower precision domain, for example a integer in int8, then actually we are finding values that will be rounded to z ( it’s just 0, since 0 with the values around it satisfies coincidently). I should emphasize that they are different! Since the rounding function is not linear, so you can’t do the operation like h(a+b)=h(a)+h(b). Note again that, when z is 0, these two ways are the same.</p>
<h3 id="Asymmetric-and-symmetric-quantization"><a href="#Asymmetric-and-symmetric-quantization" class="headerlink" title="Asymmetric and symmetric quantization"></a>Asymmetric and symmetric quantization</h3><h4 id="Asymmetric-Affine-Quantization"><a href="#Asymmetric-Affine-Quantization" class="headerlink" title="Asymmetric (Affine) Quantization"></a>Asymmetric (Affine) Quantization</h4><p>For convenience, let’s first define s as:</p>
<p><img src="image-20211214144955255.png" alt="image-20211214144955255"></p>
<p>We can use a widely used calibration method Min/Max (discuss later), which set the clip range as [β, α] = [Min_x, Max_X] and is always used in the asymmetric or symmetric quantization. Max_x and min_x is the maximum and minimum bounds of the quantizing real values (weights, bias, activation), b is the quantization bit width. This design is to make the quantized values is within the range of the lower precision:</p>
<p><img src="c5d18de467f385b522356fb0fc30d88f.png" alt="Image"></p>
<p>With Min/Max, the asymmetric quantization formula is as follows:</p>
<p><img src="bdc1f96f691ba36f76e9f9d2bf500c4b.png" alt="Image"></p>
<p>Here, the minimum bound (is negative) is chosen to corresponding to the zero-point (-zpx actually). We can adjust the choice to change the range of the lower precision. It is called asymmetric because the range on the both sides of 0 in the real set is different.</p>
<h4 id="Symmetric-Scale-Quantization"><a href="#Symmetric-Scale-Quantization" class="headerlink" title="Symmetric (Scale) Quantization"></a>Symmetric (Scale) Quantization</h4><p>If we set the zero-point as 0, then 0 and its neighbors in the real number set are maps to 0 in the lower precision domain. When we set the clip range are the same on both sides, i.e. max(|x|), then the input range and integer range are symmetric around zero and hence it is called symmetric quantization (Sometimes we don’t require the input range to be symmetric):</p>
<p><img src="028f7224f92f74c2161c21585811786b.png" alt="Image"></p>
<p>Since we need 0 maps to 0, for 8-bit quantization the integer range should be [-127, 127], deleting -128 to satisfy symmetry. Noting that it may be insignificant for 8-bit quantization since there are 256 representable values, but for lower bit quantization it should be considered signigicantly.</p>
<p>There is no zero-point in symmetric quantization (since it’s 0), the formula is simpler:</p>
<p><img src="ffac2798a6530bf4599c97747b8ba29a.png" alt="Image"></p>
<h4 id="Comparison"><a href="#Comparison" class="headerlink" title="Comparison"></a>Comparison</h4><p>Since there is no zero-point in symmetric quantization, which can lead to reduction in computational cost during inference.</p>
<p>However,  when the input range is not symmetric , such as [-20,1000], symmetric quantization will be inefficient since lots of bits in int8 are not used.</p>
<p>So, we may choose them according to the data distribution of the input. If it’s a approximately normal distribution around 0, using symmetric quantization is better. If it is activations after ReLU, it is obviously that using asymmetric quantization is better.</p>
<h3 id="Calibration"><a href="#Calibration" class="headerlink" title="Calibration"></a>Calibration</h3><p>Both in <strong>dynamic quantization and static quantization</strong> (In PTQ), we need to determine the clipping range of the parameters or activations. The following is the methods to define how to determine it.</p>
<h4 id="Min-Max"><a href="#Min-Max" class="headerlink" title="Min/Max"></a>Min/Max</h4><p>Min/Max is popular as we have introduced since it is simple. However,  it is susceptible to outlier data in activations, since there will be a waste for some bits position. </p>
<p>In static quantization (need a series of calibration inputs to do pre-calculation), the formula is as follows:</p>
<p><img src="fba76a8a630f943cde687b2512377613.png" alt="Image"></p>
<p>where X is one local sample, x is the global.</p>
<p>When we use calibration methods except Min/Max, the process will always be called saturated quantization contrast with Min/Max (unsaturated methods).</p>
<h4 id="Clipping"><a href="#Clipping" class="headerlink" title="Clipping"></a>Clipping</h4><p>We can do clipping on the input range before scaling to solve the problem of outlier:</p>
<p><img src="image-20211214162441864.png" alt="image-20211214162441864"></p>
<p>the formula of clip function may be:</p>
<p><img src="image-20211214162526049.png" alt="image-20211214162526049"></p>
<p>Some of the following methods are focus on how to find the clipping bounds.</p>
<h4 id="Exponential-moving-average-EMA"><a href="#Exponential-moving-average-EMA" class="headerlink" title="Exponential moving average (EMA)"></a>Exponential moving average (EMA)</h4><p>When clipping activations, sometimes we will use EMA (or MovingAverageMinMax):</p>
<p><img src="ff57f0dd7bc7e0b72311341a75276378.png" alt="Image"></p>
<p>where c is set as 0.01 by default. We can see that it tends to keep the history result and fine-turning according to local sample.</p>
<h4 id="Kullback-Leibler-divergence-KL"><a href="#Kullback-Leibler-divergence-KL" class="headerlink" title="Kullback-Leibler divergence (KL)"></a>Kullback-Leibler divergence (KL)</h4><p>KL-divergence, or relative entropy or information divergence  is a measure to show the relative entropy (how different) of probability distributions between two sets, which are defined on the same probability space.</p>
<p>We think that quantization will cause less information loss from the original data if the data distribution of quantized data is more similar to the original data. Such information loss can be calculated by KL-divergence (The default method used by TensorRT, a PTQ method).</p>
<p>For discrete probability distribution, P is the original data distribution that falls in several bins and Q is the quantized data histogram, the KL-divergence is:</p>
<p> <img src="image-20211214181305441.png" alt="image-20211214181305441"></p>
<p>In TensorRT, KL-divergence is used to optimize threshold selection (Since there is always a trade-off between range and precision of the int8 representation(for activations outliars)), the procedure is as follows:<br><img src="image-20211214182006243.png" alt="image-20211214182006243"></p>
<h4 id="Percentile"><a href="#Percentile" class="headerlink" title="Percentile"></a>Percentile</h4><p>Set the range to a percentile of the distribution of positive/negative values(when symmetric, absolute values) seen during calibration. For example, when 99% calibration, 1% values will be clipped.</p>
<h3 id="Dequantization"><a href="#Dequantization" class="headerlink" title="Dequantization"></a>Dequantization</h3><p>When applying QAT, the fake quantization (or simulated quantization) operations are always used, where the dequantization operation will be used.</p>
<p>In asymmetric quantization, the corresponding dequantize function is:</p>
<p><img src="image-20211215152038288.png" alt="image-20211215152038288"></p>
<p>In symmetric quantization:</p>
<p><img src="image-20211215152121988.png" alt="image-20211215152121988"></p>
<h3 id="Quantization-Granularity"><a href="#Quantization-Granularity" class="headerlink" title="Quantization Granularity"></a>Quantization Granularity</h3><p>We know that the clipping range is determined based on the input range (real numbers). The input range is determined by the input data. It is important to set where to collect the input data, or the choice for sharing the quantization parameters.</p>
<p>Tensor-wise, or layer-wise. The clipping range is determined by considering all the weights or activations in the convolutional filters of a layer.</p>
<p>Channel-wise, considering values in each channel, independent of other channels. For weights, it is kernel-wise or filter-wise.</p>
<p>We know that different channel of the features may contain different information, so the range of each convolutional filter can vary a lot. Hence, channel-wise quantization is suitable and is currently the standard method.</p>
<h2 id="Post-training-Quantization-PTQ"><a href="#Post-training-Quantization-PTQ" class="headerlink" title="Post-training-Quantization (PTQ)"></a>Post-training-Quantization (PTQ)</h2><p>With a pre-trained FP32 neural network, Post-training quantization (PTQ) algorithms convert it into a fixed-point network. This process doesn’t need training (hence no need to care about backpropagation) and can be data-free or require a series of calibration inputs.</p>
<p>How to quantize parameters depends on the types of parameters. For weight, this range can be computed statically or pre-calculated. Since weights are almost convergent during the training of floating-point model, so their range will not vary so much. However, since the input of the model is different every time, the activations in the network may have different range and it is very likely to have outlier. So we will focus on activations to do calibration (in Pytorch).</p>
<p>Dynamic quantization: the range is dynamically calculated for each activation map during runtime. We can use some real-time computation (Min/Max, percentile, etc.). It will achieve high accuracy but need more computational cost.</p>
<p>Static quantization: clipping range is pre-calculated by running a series of calibration inputs.</p>
<p>Note that there are some slight differences in the quantization on Pytorch and TensorFlow. In Dynamic quantization, the quantization of activations on Pytorch is dynamic and should be done, while on TensorFlow activations could not be quantized. When you choose to quantize activations, the computation between weights and activations will be done on Int8. When you choose not, the weights will be converted back to floating-point in computation. The static quantization in TensorFlow is called integer quantization.</p>
<h2 id="Quantization-Aware-Training-QAT"><a href="#Quantization-Aware-Training-QAT" class="headerlink" title="Quantization-Aware-Training (QAT)"></a>Quantization-Aware-Training (QAT)</h2><p>When we use PTQ, we always have accuracy loss, especially in low-precision quantization. Therefore we need some techniques to help recover the accuracy, and quantization-aware-training (QAT) is one of them. </p>
<p>QAT refers to inserting some quantization operations into the neural network and then retraining or fine-turning the network. This models the quantization noise in training to allow the network to adapt to the quantized weights and activations (but I think this may not have solid theoretical basis).</p>
<h3 id="Fake-Quantization-simulated-quantization"><a href="#Fake-Quantization-simulated-quantization" class="headerlink" title="Fake Quantization (simulated quantization)"></a>Fake Quantization (simulated quantization)</h3><p>The most common approach of QAT is fake quantization, or simulated quantization, which is a combination of quantize and dequantize operation that produces an approximation of the parameters:</p>
<p><img src="image-20211228113252203.png" alt="image-20211228113252203"></p>
<p>where x and x_hat are both floating-point values. The reason to apply fake quantization is to simulate the effects of quantization.</p>
<h3 id="Straight-Through-Estimator-STE"><a href="#Straight-Through-Estimator-STE" class="headerlink" title="Straight-Through Estimator (STE)"></a>Straight-Through Estimator (STE)</h3><p>In order to achieve such purpose, we need to retraining the simulated network. However, the gradient of the rounding operation is either 0 or undefined everywhere (step function) and then can’t be used as back-propagation. Hence, we need to design some techniques to solve such issue. Straight-through estimator is one of the solutions by approximating the gradient of the rounding operator as 1:</p>
<p><img src="image-20211228141327650.png" alt="image-20211228141327650"></p>
<p>By using this, we we can calculate the gradient of the quantize and dequantize operation w.r.t the input:</p>
<p><img src="image-20211228142202635.png" alt="image-20211228142202635"></p>
<p>where [q_min,q_max] is the clipping range (the s in this picture equals to the 1/s of previous).</p>
<p>Note that we actually skip the quantize and dequantize operation in backward pass since STE approximates the gradient as 1 when the input is in the clipping range.</p>
<h3 id="Learning-Quantization-Parameters"><a href="#Learning-Quantization-Parameters" class="headerlink" title="Learning Quantization Parameters"></a>Learning Quantization Parameters</h3><p>As we have indicated, the quantization parameters (clipping range) depend on the inference by using a set of calibration. But we also can learn the quantization parameters along with the model weights. PACT……</p>
<p><strong>!!!!!</strong> <strong>After training, the network is transformed by quantization again (i.e. using static quantization) to the low-precision network.</strong></p>
<h2 id="Gradient-quantization-full-training"><a href="#Gradient-quantization-full-training" class="headerlink" title="Gradient quantization (full training)"></a>Gradient quantization (full training)</h2>]]></content>
      <categories>
        <category>Knowledge</category>
      </categories>
      <tags>
        <tag>Efficient_Neural_Network</tag>
      </tags>
  </entry>
  <entry>
    <title>python内置函数总结</title>
    <url>/2021/11/05/python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>这篇总结目的是为了自己记忆和查找 大部分都是从<a href="http://www.runoob.com/">www.runoob.com</a> 看来的</p>
<h3 id="abs"><a href="#abs" class="headerlink" title="abs()"></a>abs()</h3><p>返回数字的绝对值</p>
<span id="more"></span>

<p>example：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; abs(-45)</span><br><span class="line">45</span><br></pre></td></tr></table></figure>

<h3 id="all"><a href="#all" class="headerlink" title="all()"></a>all()</h3><p>判断可迭代参数中的所有元素是否都为true.</p>
<p>当所有元素不为0，空，False, None时， 返回True，否则False.</p>
<p>但是空列表和空元组返回True</p>
<p>（其实就是变相找参数里边有没有0，空，False, None）</p>
<p>example：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; all([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;])</span><br><span class="line">True</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; all([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;&#x27;, &#x27;d&#x27;])</span><br><span class="line">False</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; all((0, 1, 2, 3))          </span><br><span class="line">False</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; all([])             # 空列表</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<h3 id="any"><a href="#any" class="headerlink" title="any()"></a>any()</h3><p>判断参数里边有没有True</p>
<p>只要参数里有除了0，空，False, None之外的内容，就返回True</p>
<p>但空列表，空元组直接返回False</p>
<p>（其实就是变相找参数里边有没有True）</p>
<p>example：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;any([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;])  # 列表list，元素都不为空或0</span><br><span class="line">True</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; any([0, &#x27;&#x27;, False])        # 列表list,元素全为0,&#x27;&#x27;,false</span><br><span class="line">False</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; any([]) # 空列表</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<p>上边两个函数为什么当参数是空的时候，结果是这么的不一样，其实可以从它们的等价函数看出来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def all(iterable):</span><br><span class="line">    for element in iterable:</span><br><span class="line">        if not element:</span><br><span class="line">            return False</span><br><span class="line">    return True</span><br></pre></td></tr></table></figure>

<p>当参数是空的时候，for语句直接跳过了，所以这里all就会直接返回True</p>
<h3 id="ascii"><a href="#ascii" class="headerlink" title="ascii()"></a>ascii()</h3><p>ascii() 函数类似 repr() 函数, 返回一个表示对象的字符串, 但是对于字符串中的非 ASCII 字符则返回通过 repr() 函数使用 \x, \u 或 \U 编码的字符。 生成字符串类似 Python2 版本中 repr() 函数的返回值。</p>
<p>其实就是用ascii来解码（decode）数值</p>
<p>example：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; ascii(&#x27;runoob&#x27;)</span><br><span class="line">&quot;&#x27;runoob&#x27;&quot;</span><br></pre></td></tr></table></figure>

<h3 id="bin"><a href="#bin" class="headerlink" title="bin()"></a>bin()</h3><p>返回一个整数 int 或者长整数 long int 的二进制表示。</p>
<p>example：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;bin(10)</span><br><span class="line">&#x27;0b1010&#x27;</span><br><span class="line">&gt;&gt;&gt; bin(20)</span><br><span class="line">&#x27;0b10100&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="bool"><a href="#bool" class="headerlink" title="bool()"></a>bool()</h3><p>将参数化为bool类型，没参数就返回False</p>
<p>example：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;bool()</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; bool(0)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; bool(1)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p>值得一提的是，这里也是只有参数为0，空，False, None才返回False, 其他的比如bool((0,0))也是返回True, 因为这里判断（0,0）是个整体且不是上边四种之一。</p>
<h3 id="bytearray"><a href="#bytearray" class="headerlink" title="bytearray()"></a>bytearray()</h3><p>把字符串(char)转化为字节(byte)</p>
<p>语法是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bytearray(string, encoding[, errors]) -&gt; bytearray</span><br></pre></td></tr></table></figure>

<p>首先要理解这里什么是”编码(encoding)”：指某种将 Unicode 字符串转换为字节序列（bytearray对象）的规则，其包含了从”抽象字符序列”(char)到”字节序列”(byte)的全部过程。比如说“utf-8”,”ascii”.</p>
<p>一般，当source是个字符串时,一定要在函数的第二位加上encoding。</p>
<p>有的时候encoding并不能编码字符串，这个时候就需要设立函数第三位“errors”，也就是错误处理方案。默认’strict’会在编码错误时抛出UnicodeError. 也可自己设置是’ignore’<code>, </code>‘replace’<code>, </code>‘xmlcharrefreplace’<code>, </code>‘backslashreplace’。</p>
<p>example：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; bytearray(&#x27;abcd&#x27;,&#x27;utf-8&#x27;)</span><br><span class="line">bytearray(b&#x27;abcd&#x27;)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; bytearray(&#x27;鲸&#x27;,&#x27;utf-8&#x27;)</span><br><span class="line">bytearray(b&#x27;\xe9\xb2\xb8&#x27;)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; bytearray(&#x27;鲸&#x27;,&#x27;ascii&#x27;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#11&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    bytearray(&#x27;鲸&#x27;,&#x27;ascii&#x27;)</span><br><span class="line">UnicodeEncodeError: &#x27;ascii&#x27; codec can&#x27;t encode character &#x27;\u9cb8&#x27; in position 0: ordinal not in range(128)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; bytearray(&#x27;鲸&#x27;,&#x27;ascii&#x27;,&#x27;ignore&#x27;)</span><br><span class="line">bytearray(b&#x27;&#x27;)</span><br></pre></td></tr></table></figure>

<p>和C语言不同，bytearray会以转义序列或ASCII字符显示相应数值(如，将十进制整数 65 显示为字母 A)，但根源上bytearray对象的每个索引位置依旧是数值并非字符。（bytearray对象指的是这个函数的输出）</p>
<p>下面演示一些它如何显示数值的：</p>
<p>如果索引位置对应ASCII编码中可见的字符，那么bytearray对象的索引位就会直接显示该字符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; bytearray((0x41, 0x42))</span><br><span class="line">bytearray(b&#x27;AB&#x27;)</span><br></pre></td></tr></table></figure>

<p>如果是ASCII中的不可见字符，但该字符有“独立转义序列”，那么就显示“独立转义序列”：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; bytearray((0x0A, 0x0D))</span><br><span class="line">bytearray(b&#x27;\n\r&#x27;)</span><br></pre></td></tr></table></figure>

<p>如果是不可见字符且没有“独立转义序列”或超出ASCII的范围，那么索引位置会显示十六进制(<code>&#39;\xhh&#39;</code>)转义序列。在 bytearray 对象中，十六进制(<code>&#39;\xhh&#39;</code>)转义序列用于表示具有指定数值的字节。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; bytearray((0x01, 0xFE))</span><br><span class="line">bytearray(b&#x27;\x01\xfe&#x27;)</span><br></pre></td></tr></table></figure>

<p>这样方便的是，如果各个字节的数值正好是ASCII相应字节，那么不用解码就可以直接读懂。（a.decode(‘b’)来解码，a代表一个bytearay实例，b某encoding方法）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; hi = bytearray(&#x27;hello!\n&#x27;,&#x27;ascii&#x27;)</span><br><span class="line">&gt;&gt;&gt; hi</span><br><span class="line">bytearray(b&#x27;hello!\n&#x27;) # 虽然是字节序列，但是不用解码也读懂</span><br><span class="line">&gt;&gt;&gt; hi.decode(&#x27;ascii&#x27;)</span><br><span class="line">&#x27;hello!\n&#x27;</span><br></pre></td></tr></table></figure>



<p>除了上边说的，bytearray()也有一些特殊用法：</p>
<p>source 没任何参数时，创建一个空实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># bytearray() -&gt; empty bytes array</span><br><span class="line">&gt;&gt;&gt; bytearray()</span><br><span class="line">bytearray(b&#x27;&#x27;)</span><br></pre></td></tr></table></figure>

<p>source 是一个<strong>整数</strong>时，将创建一个长度为 <em>source</em> 且每个字节均为空的 bytearray 对象:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># bytearray(int) -&gt; bytearray</span><br><span class="line">&gt;&gt;&gt; bytearray(5)</span><br><span class="line">bytearray(b&#x27;\x00\x00\x00\x00\x00&#x27;)</span><br></pre></td></tr></table></figure>

<p><em>source</em> 是一个由自然数构成的<strong>可迭代对象</strong>，且每个元素的值 x 均满足 0 ≤ x ≤ 255:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># bytearray(iterable_of_ints) -&gt; bytearray</span><br><span class="line">&gt;&gt;&gt; bytearray(range(5)) # 最大范围是range(256)</span><br><span class="line">bytearray(b&#x27;\x00\x01\x02\x03\x04&#x27;)</span><br><span class="line">&gt;&gt;&gt; bytearray([1,2,3,4,5])</span><br><span class="line">bytearray(b&#x27;\x01\x02\x03\x04\x05&#x27;)</span><br></pre></td></tr></table></figure>

<p><em>source</em> 是一个 bytes 对象，将通过缓冲器协议(buffer protocol)复制其中的二进制数据:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># bytearray(bytes) -&gt; mutable copy of bytes</span><br><span class="line">&gt;&gt;&gt; bytearray(b&#x27;Hi!&#x27;)</span><br><span class="line">bytearray(b&#x27;Hi!&#x27;)</span><br></pre></td></tr></table></figure>

<p><em>source</em> 是一个实现了缓冲区(buffer) API 的对象时，则会使用 <em>source</em> 的只读缓冲区来初始化 bytearray 对象。(这个我现在还不太懂)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># bytearray(buffer) -&gt; mutable copy of buffer</span><br></pre></td></tr></table></figure>

<h3 id="bytes"><a href="#bytes" class="headerlink" title="bytes()"></a>bytes()</h3><p>bytearray 的不可变版本, 语法什么的都和bytearray一样</p>
<p>example：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;a = bytes([1,2,3,4])</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">b&#x27;\x01\x02\x03\x04&#x27;</span><br><span class="line">&gt;&gt;&gt; type(a)</span><br><span class="line">&lt;class &#x27;bytes&#x27;&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; a = bytes(&#x27;hello&#x27;,&#x27;ascii&#x27;)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">b&#x27;hello&#x27;</span><br><span class="line">&gt;&gt;&gt; type(a)</span><br><span class="line">&lt;class &#x27;bytes&#x27;&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="callable"><a href="#callable" class="headerlink" title="callable()"></a>callable()</h3><p>检查一个对象是否是可调用的。如果返回 True，object 仍然可能调用失败；但如果返回 False，调用对象 object 绝对不会成功。</p>
<p>对于函数、方法、lambda 函式、 类以及实现了 <strong><strong>call</strong></strong> 方法的类实例, 它都返回 True。</p>
<p>example：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;callable(0)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; callable(&quot;runoob&quot;)</span><br><span class="line">False</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; def add(a, b):</span><br><span class="line">...     return a + b</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; callable(add)             # 函数返回 True</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; class A:                  # 类</span><br><span class="line">...     def method(self):</span><br><span class="line">...             return 0</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; callable(A)               # 类返回 True</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; a = A()</span><br><span class="line">&gt;&gt;&gt; callable(a)               # 没有实现 __call__, 返回 False</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; class B:</span><br><span class="line">...     def __call__(self):</span><br><span class="line">...             return 0</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; callable(B)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; b = B()</span><br><span class="line">&gt;&gt;&gt; callable(b)               # 实现 __call__, 返回 True</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p>那怎么样算是可调用呢？ 我现在的理解是可以作为一个工具，实现一定的作用。比如类就可以作为创建某个类实例的工具，加了**<strong>call</strong>** 方法的类实例可以作为“print”这个类先写好的某个内容的工具。</p>
<h3 id="chr"><a href="#chr" class="headerlink" title="chr()"></a>chr()</h3><p>用一个范围在 range（256）内的（就是0～255）整数作参数，返回一个对应的字符。</p>
<p>这个整数可以是10进制也可以是16进制的形式的数字。</p>
<p>将会返回当前整数对应的 ASCII 字符。</p>
<p>example：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;print chr(0x30), chr(0x31), chr(0x61)   # 十六进制</span><br><span class="line">0 1 a</span><br><span class="line">&gt;&gt;&gt; print chr(48), chr(49), chr(97)         # 十进制</span><br><span class="line">0 1 a</span><br></pre></td></tr></table></figure>

<p>（待会儿我会把ASCII表放到Blog上）</p>
<h3 id="classmethod"><a href="#classmethod" class="headerlink" title="classmethod"></a>classmethod</h3><p><strong>classmethod</strong> 修饰符对应的函数不需要实例化，不需要 self 参数，但第一个参数需要是表示自身类的 cls 参数，可以来调用类的属性，类的方法，实例化对象等。</p>
<p>这是一个不需要把类实例化就可以调用类里面的function的修饰符（？）</p>
<p>example：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A(object):</span><br><span class="line">    bar = 1</span><br><span class="line">    def func1(self):  </span><br><span class="line">        print (&#x27;foo&#x27;) </span><br><span class="line">    @classmethod</span><br><span class="line">    def func2(cls):</span><br><span class="line">        print (&#x27;func2&#x27;)</span><br><span class="line">        print (cls.bar)</span><br><span class="line">        cls().func1()   # 调用 foo 方法</span><br><span class="line"> </span><br><span class="line">A.func2()               # 不需要实例化</span><br></pre></td></tr></table></figure>

<p>上边这个例子就是直接用类的名字（A）来调用了函数.</p>
<h3 id="cmp"><a href="#cmp" class="headerlink" title="cmp()"></a>cmp()</h3><p>cmp(x,y) 函数用于比较2个对象，如果 x &lt; y 返回 -1, 如果 x == y 返回 0, 如果 x &gt; y 返回 1。</p>
<p>example：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmp(80, 100) :  -1</span><br><span class="line">cmp(180, 100) :  1</span><br><span class="line">cmp(-80, 100) :  -1</span><br><span class="line">cmp(80, -100) :  1</span><br></pre></td></tr></table></figure>

<p>但是现在python3应该是没cmp函数了，需要实现比较功能可以import operator：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">operator.lt(a, b)</span><br><span class="line">operator.le(a, b)</span><br><span class="line">operator.eq(a, b)</span><br><span class="line">operator.ne(a, b)</span><br><span class="line">operator.ge(a, b)</span><br><span class="line">operator.gt(a, b)</span><br><span class="line">operator.__lt__(a, b)</span><br><span class="line">operator.__le__(a, b)</span><br><span class="line">operator.__eq__(a, b)</span><br><span class="line">operator.__ne__(a, b)</span><br><span class="line">operator.__ge__(a, b)</span><br><span class="line">operator.__gt__(a, b)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import operator</span><br><span class="line">&gt;&gt;&gt; operator.eq(&#x27;hello&#x27;, &#x27;name&#x27;);</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; operator.eq(&#x27;hello&#x27;, &#x27;hello&#x27;);</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p>lt就是less than，le就是less or equal，ne是not equal</p>
<h3 id="compile"><a href="#compile" class="headerlink" title="compile()"></a>compile()</h3><p>把一个字符串当作代码来编译</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">compile(source, filename, mode[, flags[, dont_inherit]])</span><br><span class="line"></span><br><span class="line">source -- 字符串或者AST（Abstract Syntax Trees）对象。。</span><br><span class="line">filename -- 代码文件名称，如果不是从文件读取代码则传递一些可辨认的值。</span><br><span class="line">mode -- 指定编译代码的种类。可以指定为 exec, eval, single。</span><br><span class="line">flags -- 变量作用域，局部命名空间，如果被提供，可以是任何映射对象。。</span><br><span class="line">flags和dont_inherit是用来控制编译源码时的标志</span><br></pre></td></tr></table></figure>

<p>返回执行结果</p>
<p>example：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;str = &quot;for i in range(0,10): print(i)&quot; </span><br><span class="line">&gt;&gt;&gt; c = compile(str,&#x27;&#x27;,&#x27;exec&#x27;)   # 编译为字节代码对象 </span><br><span class="line">&gt;&gt;&gt; c</span><br><span class="line">&lt;code object &lt;module&gt; at 0x10141e0b0, file &quot;&quot;, line 1&gt;</span><br><span class="line">&gt;&gt;&gt; exec(c)</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; str = &quot;3 * 4 + 5&quot;</span><br><span class="line">&gt;&gt;&gt; a = compile(str,&#x27;&#x27;,&#x27;eval&#x27;)</span><br><span class="line">&gt;&gt;&gt; eval(a)</span><br><span class="line">17</span><br></pre></td></tr></table></figure>

<h3 id="complex"><a href="#complex" class="headerlink" title="complex()"></a>complex()</h3><p>创建一个复数，或者把一个数或者字符串转化为复数</p>
<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;complex(1, 2)</span><br><span class="line">(1 + 2j)</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; complex(1)    # 数字</span><br><span class="line">(1 + 0j)</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; complex(&quot;1&quot;)  # 当做字符串处理</span><br><span class="line">(1 + 0j)</span><br><span class="line"> </span><br><span class="line"># 注意：这个地方在&quot;+&quot;号两边不能有空格，也就是不能写成&quot;1 + 2j&quot;，应该是&quot;1+2j&quot;，否则会报错</span><br><span class="line">&gt;&gt;&gt; complex(&quot;1+2j&quot;)</span><br><span class="line">(1 + 2j)</span><br></pre></td></tr></table></figure>

<h3 id="delattr"><a href="#delattr" class="headerlink" title="delattr()"></a>delattr()</h3><p>把一个对象的某个属性删除</p>
<p><strong>delattr(x, ‘foobar’)</strong> 相等于 <strong>del x.foobar</strong>。</p>
<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Coordinate:</span><br><span class="line">    x = 10</span><br><span class="line">    y = -5</span><br><span class="line">    z = 0</span><br><span class="line"> </span><br><span class="line">point1 = Coordinate() </span><br><span class="line"> </span><br><span class="line">print(&#x27;x = &#x27;,point1.x)</span><br><span class="line">print(&#x27;y = &#x27;,point1.y)</span><br><span class="line">print(&#x27;z = &#x27;,point1.z)</span><br><span class="line"> </span><br><span class="line">delattr(Coordinate, &#x27;z&#x27;)</span><br><span class="line"> </span><br><span class="line">print(&#x27;--删除 z 属性后--&#x27;)</span><br><span class="line">print(&#x27;x = &#x27;,point1.x)</span><br><span class="line">print(&#x27;y = &#x27;,point1.y)</span><br><span class="line"> </span><br><span class="line"># 触发错误</span><br><span class="line">print(&#x27;z = &#x27;,point1.z)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(&#x27;x = &#x27;, 10)</span><br><span class="line">(&#x27;y = &#x27;, -5)</span><br><span class="line">(&#x27;z = &#x27;, 0)</span><br><span class="line">--删除 z 属性后--</span><br><span class="line">(&#x27;x = &#x27;, 10)</span><br><span class="line">(&#x27;y = &#x27;, -5)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;test.py&quot;, line 22, in &lt;module&gt;</span><br><span class="line">    print(&#x27;z = &#x27;,point1.z)</span><br><span class="line">AttributeError: Coordinate instance has no attribute &#x27;z&#x27;</span><br></pre></td></tr></table></figure>

<p>上边这个例子里就是把Coordinate这个类的z这个属性删除了。</p>
<h3 id="dict"><a href="#dict" class="headerlink" title="dict()"></a>dict()</h3><p>用于创建一个字典。</p>
<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;dict()                        # 创建空字典</span><br><span class="line">&#123;&#125;</span><br><span class="line">&gt;&gt;&gt; dict(a=&#x27;a&#x27;, b=&#x27;b&#x27;, t=&#x27;t&#x27;)     # 传入关键字</span><br><span class="line">&#123;&#x27;a&#x27;: &#x27;a&#x27;, &#x27;b&#x27;: &#x27;b&#x27;, &#x27;t&#x27;: &#x27;t&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; dict(zip([&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;], [1, 2, 3]))   # 映射函数方式来构造字典</span><br><span class="line">&#123;&#x27;three&#x27;: 3, &#x27;two&#x27;: 2, &#x27;one&#x27;: 1&#125; </span><br><span class="line">&gt;&gt;&gt; dict([(&#x27;one&#x27;, 1), (&#x27;two&#x27;, 2), (&#x27;three&#x27;, 3)])    # 可迭代对象方式来构造字典</span><br><span class="line">&#123;&#x27;three&#x27;: 3, &#x27;two&#x27;: 2, &#x27;one&#x27;: 1&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="dir"><a href="#dir" class="headerlink" title="dir()"></a>dir()</h3><p><strong>dir()</strong> 函数不带参数时，返回当前范围内的变量、方法和定义的类型列表；带参数时，返回参数的属性、方法列表。如果参数包含方法__dir__()，该方法将被调用。如果参数不包含__dir__()，该方法将最大限度地收集参数信息。</p>
<p>简单来说就相当于一个help</p>
<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;dir()   #  获得当前模块的属性列表</span><br><span class="line">[&#x27;__builtins__&#x27;, &#x27;__doc__&#x27;, &#x27;__name__&#x27;, &#x27;__package__&#x27;, &#x27;arr&#x27;, &#x27;myslice&#x27;]</span><br><span class="line">&gt;&gt;&gt; dir([ ])    # 查看列表的方法</span><br><span class="line">[&#x27;__add__&#x27;, &#x27;__class__&#x27;, &#x27;__contains__&#x27;, &#x27;__delattr__&#x27;, &#x27;__delitem__&#x27;, &#x27;__delslice__&#x27;, &#x27;__doc__&#x27;, &#x27;__eq__&#x27;, &#x27;__format__&#x27;, &#x27;__ge__&#x27;, &#x27;__getattribute__&#x27;, &#x27;__getitem__&#x27;, &#x27;__getslice__&#x27;, &#x27;__gt__&#x27;, &#x27;__hash__&#x27;, &#x27;__iadd__&#x27;, &#x27;__imul__&#x27;, &#x27;__init__&#x27;, &#x27;__iter__&#x27;, &#x27;__le__&#x27;, &#x27;__len__&#x27;, &#x27;__lt__&#x27;, &#x27;__mul__&#x27;, &#x27;__ne__&#x27;, &#x27;__new__&#x27;, &#x27;__reduce__&#x27;, &#x27;__reduce_ex__&#x27;, &#x27;__repr__&#x27;, &#x27;__reversed__&#x27;, &#x27;__rmul__&#x27;, &#x27;__setattr__&#x27;, &#x27;__setitem__&#x27;, &#x27;__setslice__&#x27;, &#x27;__sizeof__&#x27;, &#x27;__str__&#x27;, &#x27;__subclasshook__&#x27;, &#x27;append&#x27;, &#x27;count&#x27;, &#x27;extend&#x27;, &#x27;index&#x27;, &#x27;insert&#x27;, &#x27;pop&#x27;, &#x27;remove&#x27;, &#x27;reverse&#x27;, &#x27;sort&#x27;]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="divmod"><a href="#divmod" class="headerlink" title="divmod()"></a>divmod()</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">divmod(a, b)</span><br></pre></td></tr></table></figure>

<p>接收两个数字类型（非复数）参数，返回一个包含商和余数的元组(a // b, a % b)。</p>
<p>如果参数 a 与 参数 b 都是整数，函数返回的结果相当于 **(a // b, a % b)**。</p>
<p>如果其中一个参数为浮点数时，函数返回的结果相当于 (q, a % b)，q 通常是 math.floor(a / b)，但也有可能是 1 ，比(精准的值)小，不过 q * b + a % b 的值会非常接近 a。</p>
<p>如果 a % b 的求余结果不为 0 ，则余数的正负符号跟参数 b 是一样的，若 b 是正数，余数为正数，若 b 为负数，余数也为负数，并且 0 &lt;= abs(a % b) &lt; abs(b)。</p>
<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; divmod(7, 2)</span><br><span class="line">(3, 1)</span><br><span class="line">&gt;&gt;&gt; divmod(8, 2)</span><br><span class="line">(4, 0)</span><br><span class="line">&gt;&gt;&gt; divmod(8, -2)</span><br><span class="line">(-4, 0)</span><br><span class="line">&gt;&gt;&gt; divmod(3, 1.3)</span><br><span class="line">(2.0, 0.3999999999999999)</span><br></pre></td></tr></table></figure>

<h3 id="enumerate"><a href="#enumerate" class="headerlink" title="enumerate()"></a>enumerate()</h3><p>用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enumerate(sequence, [start=0])</span><br></pre></td></tr></table></figure>

<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; seasons = [&#x27;Spring&#x27;, &#x27;Summer&#x27;, &#x27;Fall&#x27;, &#x27;Winter&#x27;]</span><br><span class="line">&gt;&gt;&gt; list(enumerate(seasons))</span><br><span class="line">[(0, &#x27;Spring&#x27;), (1, &#x27;Summer&#x27;), (2, &#x27;Fall&#x27;), (3, &#x27;Winter&#x27;)]</span><br><span class="line">&gt;&gt;&gt; list(enumerate(seasons, start=1))       # 小标从 1 开始</span><br><span class="line">[(1, &#x27;Spring&#x27;), (2, &#x27;Summer&#x27;), (3, &#x27;Fall&#x27;), (4, &#x27;Winter&#x27;)]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">seq = [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;]</span><br><span class="line">for i, element in enumerate(seq):</span><br><span class="line">    print(i, element)</span><br></pre></td></tr></table></figure>

<h3 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h3><p>函数用来执行一个字符串表达式，并返回表达式的值。</p>
<p>简单来说就是运行某段代码，输出结果，可以作为一个expression</p>
<p>example：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;x = 7</span><br><span class="line">&gt;&gt;&gt; eval( &#x27;3 * x&#x27; )</span><br><span class="line">21</span><br><span class="line">&gt;&gt;&gt; eval(&#x27;pow(2,2)&#x27;)</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; eval(&#x27;2 + 2&#x27;)</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; n=81</span><br><span class="line">&gt;&gt;&gt; eval(&quot;n + 4&quot;)</span><br><span class="line">85</span><br></pre></td></tr></table></figure>

<h3 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h3><p>执行储存在字符串或文件中的 Python 语句，相比于 eval，exec可以执行更复杂的 Python 代码。</p>
<p>更复杂代表里边可以有其他的更复杂的函数</p>
<p>example：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;exec(&#x27;print(&quot;Hello World&quot;)&#x27;)</span><br><span class="line">Hello World</span><br><span class="line"># 单行语句字符串</span><br><span class="line">&gt;&gt;&gt; exec(&quot;print (&#x27;runoob.com&#x27;)&quot;)</span><br><span class="line">runoob.com</span><br><span class="line"> </span><br><span class="line">#  多行语句字符串</span><br><span class="line">&gt;&gt;&gt; exec (&quot;&quot;&quot;for i in range(5):</span><br><span class="line">...     print (&quot;iter time: %d&quot; % i)</span><br><span class="line">... &quot;&quot;&quot;)</span><br><span class="line">iter time: 0</span><br><span class="line">iter time: 1</span><br><span class="line">iter time: 2</span><br><span class="line">iter time: 3</span><br><span class="line">iter time: 4</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = 10</span><br><span class="line">expr = &quot;&quot;&quot;</span><br><span class="line">z = 30</span><br><span class="line">sum = x + y + z</span><br><span class="line">print(sum)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">def func():</span><br><span class="line">    y = 20</span><br><span class="line">    exec(expr)</span><br><span class="line">    exec(expr, &#123;&#x27;x&#x27;: 1, &#x27;y&#x27;: 2&#125;)</span><br><span class="line">    exec(expr, &#123;&#x27;x&#x27;: 1, &#x27;y&#x27;: 2&#125;, &#123;&#x27;y&#x27;: 3, &#x27;z&#x27;: 4&#125;)</span><br><span class="line">    </span><br><span class="line">func()</span><br></pre></td></tr></table></figure>

<p>这里也涉及到了一些关于global，local的问题。</p>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">filter(function, iterable)</span><br></pre></td></tr></table></figure>

<p>用于过滤序列，过滤掉不符合条件的元素，返回一个迭代器对象，如果要转换为列表，可以使用 <strong>list()</strong> 来转换。</p>
<p>该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判断，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。</p>
<p>example：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def is_odd(n):</span><br><span class="line">    return n % 2 == 1</span><br><span class="line"> </span><br><span class="line">tmplist = filter(is_odd, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])</span><br><span class="line">newlist = list(tmplist)</span><br><span class="line">print(newlist)</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">[1, 3, 5, 7, 9]</span><br></pre></td></tr></table></figure>

<h3 id="float"><a href="#float" class="headerlink" title="float()"></a>float()</h3><p>将整数和字符串转换成浮点数。</p>
<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;float(1)</span><br><span class="line">1.0</span><br><span class="line">&gt;&gt;&gt; float(112)</span><br><span class="line">112.0</span><br><span class="line">&gt;&gt;&gt; float(-123.6)</span><br><span class="line">-123.6</span><br><span class="line">&gt;&gt;&gt; float(&#x27;123&#x27;)     # 字符串</span><br><span class="line">123.0</span><br></pre></td></tr></table></figure>

<h3 id="format"><a href="#format" class="headerlink" title="format()"></a>format()</h3><p>Python2.6 开始，新增了一种格式化字符串的函数 **str.format()**，它增强了字符串格式化的功能。</p>
<p>基本语法是通过 <strong>{}</strong> 和 <strong>:</strong> 来代替以前的 <strong>%</strong> 。</p>
<p>format 函数可以接受不限个参数，位置可以不按顺序。</p>
<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;&quot;&#123;&#125; &#123;&#125;&quot;.format(&quot;hello&quot;, &quot;world&quot;)    # 不设置指定位置，按默认顺序</span><br><span class="line">&#x27;hello world&#x27;</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; &quot;&#123;0&#125; &#123;1&#125;&quot;.format(&quot;hello&quot;, &quot;world&quot;)  # 设置指定位置</span><br><span class="line">&#x27;hello world&#x27;</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; &quot;&#123;1&#125; &#123;0&#125; &#123;1&#125;&quot;.format(&quot;hello&quot;, &quot;world&quot;)  # 设置指定位置</span><br><span class="line">&#x27;world hello world&#x27;</span><br></pre></td></tr></table></figure>

<p>{}内也可以设置参数</p>
<p>也可以格式化数字：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&quot;&#123;:.2f&#125;&quot;.format(3.1415926))</span><br><span class="line">3.14</span><br></pre></td></tr></table></figure>

<p><img src="image-20211106000703005.png" alt="image-20211106000703005"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;print (&quot;&#123;&#125; 对应的位置是 &#123;&#123;0&#125;&#125;&quot;.format(&quot;runoob&quot;))</span><br><span class="line">runoob 对应的位置是 &#123;0&#125;</span><br></pre></td></tr></table></figure>

<h3 id="frozenset"><a href="#frozenset" class="headerlink" title="frozenset()"></a>frozenset()</h3><p>返回一个冻结的集合，冻结后集合不能再添加或删除任何元素。</p>
<p>首先要明白什么是集合（set）：集合（set）是一个无序的不重复元素序列。</p>
<p>可以使用大括号 <strong>{ }</strong> 或者 <strong>set()</strong> 函数创建集合，注意：创建一个空集合必须用 <strong>set()</strong> 而不是 **{ }**，因为 <strong>{ }</strong> 是用来创建一个空字典。</p>
<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; basket = &#123;&#x27;apple&#x27;, &#x27;orange&#x27;, &#x27;apple&#x27;, &#x27;pear&#x27;, &#x27;orange&#x27;, &#x27;banana&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; print(basket)                      # 这里演示的是去重功能</span><br><span class="line">&#123;&#x27;orange&#x27;, &#x27;banana&#x27;, &#x27;pear&#x27;, &#x27;apple&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; &#x27;orange&#x27; in basket                 # 快速判断元素是否在集合内</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; &#x27;crabgrass&#x27; in basket</span><br><span class="line">False</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; # 下面展示两个集合间的运算.</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; a = set(&#x27;abracadabra&#x27;)</span><br><span class="line">&gt;&gt;&gt; b = set(&#x27;alacazam&#x27;)</span><br><span class="line">&gt;&gt;&gt; a                                  </span><br><span class="line">&#123;&#x27;a&#x27;, &#x27;r&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; a - b                              # 集合a中包含而集合b中不包含的元素</span><br><span class="line">&#123;&#x27;r&#x27;, &#x27;d&#x27;, &#x27;b&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; a | b                              # 集合a或b中包含的所有元素</span><br><span class="line">&#123;&#x27;a&#x27;, &#x27;c&#x27;, &#x27;r&#x27;, &#x27;d&#x27;, &#x27;b&#x27;, &#x27;m&#x27;, &#x27;z&#x27;, &#x27;l&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; a &amp; b                              # 集合a和b中都包含了的元素</span><br><span class="line">&#123;&#x27;a&#x27;, &#x27;c&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; a ^ b                              # 不同时包含于a和b的元素</span><br><span class="line">&#123;&#x27;r&#x27;, &#x27;d&#x27;, &#x27;b&#x27;, &#x27;m&#x27;, &#x27;z&#x27;, &#x27;l&#x27;&#125;</span><br></pre></td></tr></table></figure>

<p>集合适用于集合推导式(Set comprehension)，类似于列表推导式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a = &#123;x for x in &#x27;abracadabra&#x27; if x not in &#x27;abc&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&#123;&#x27;r&#x27;, &#x27;d&#x27;&#125;</span><br></pre></td></tr></table></figure>

<p>下面说frozenset</p>
<p>返回一个冻结的集合，冻结后集合不能再添加或删除任何元素。</p>
<p>要知道在数学的定义里，集合可能是包含在另一个集合里的，但我们这里的集合，是要求元素是不变的，所以在这里集合就不能包含在集合中（因为事实上这里的集合是可变的），所以就需要一种不可变的集合来实现这个功能，也就是frozenset</p>
<p>example：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;a = frozenset(range(10))     # 生成一个新的不可变集合</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">frozenset([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span><br><span class="line">&gt;&gt;&gt; b = frozenset(&#x27;runoob&#x27;) </span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">frozenset([&#x27;b&#x27;, &#x27;r&#x27;, &#x27;u&#x27;, &#x27;o&#x27;, &#x27;n&#x27;])   # 创建不可变集合</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="getattr"><a href="#getattr" class="headerlink" title="getattr()"></a>getattr()</h3><p>用于返回一个对象属性值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getattr(object, name[, default])</span><br><span class="line"></span><br><span class="line">object -- 对象。</span><br><span class="line">name -- 字符串，对象属性。</span><br><span class="line">default -- 默认返回值，如果不提供该参数，在没有对应属性时，将触发 AttributeError。</span><br></pre></td></tr></table></figure>

<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;class A(object):</span><br><span class="line">...     bar = 1</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; a = A()</span><br><span class="line">&gt;&gt;&gt; getattr(a, &#x27;bar&#x27;)        # 获取属性 bar 值</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; getattr(a, &#x27;bar2&#x27;)       # 属性 bar2 不存在，触发异常</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">AttributeError: &#x27;A&#x27; object has no attribute &#x27;bar2&#x27;</span><br><span class="line">&gt;&gt;&gt; getattr(a, &#x27;bar2&#x27;, 3)    # 属性 bar2 不存在，但设置了默认值</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="hasattr"><a href="#hasattr" class="headerlink" title="hasattr()"></a>hasattr()</h3><p>用于判断对象是否包含对应的属性。</p>
<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Coordinate:</span><br><span class="line">    x = 10</span><br><span class="line">    y = -5</span><br><span class="line">    z = 0</span><br><span class="line"> </span><br><span class="line">point1 = Coordinate() </span><br><span class="line">print(hasattr(point1, &#x27;x&#x27;))</span><br><span class="line">print(hasattr(point1, &#x27;y&#x27;))</span><br><span class="line">print(hasattr(point1, &#x27;z&#x27;))</span><br><span class="line">print(hasattr(point1, &#x27;no&#x27;))  # 没有该属性</span><br><span class="line"></span><br><span class="line">True</span><br><span class="line">True</span><br><span class="line">True</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<h3 id="hash"><a href="#hash" class="headerlink" title="hash()"></a>hash()</h3><p>获取取一个对象（字符串或者数值等）的哈希值。</p>
<p>(目前我还不知道什么是哈希值)</p>
<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;hash(&#x27;test&#x27;)            # 字符串</span><br><span class="line">2314058222102390712</span><br><span class="line">&gt;&gt;&gt; hash(1)                 # 数字</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; hash(str([1,2,3]))      # 集合</span><br><span class="line">1335416675971793195</span><br><span class="line">&gt;&gt;&gt; hash(str(sorted(&#123;&#x27;1&#x27;:1&#125;))) # 字典</span><br><span class="line">7666464346782421378</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="help"><a href="#help" class="headerlink" title="help()"></a>help()</h3><p>用于查看函数或模块用途的详细说明。</p>
<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;help(&#x27;sys&#x27;)             # 查看 sys 模块的帮助</span><br><span class="line">……显示帮助信息……</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt;help(&#x27;str&#x27;)             # 查看 str 数据类型的帮助</span><br><span class="line">……显示帮助信息……</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt;a = [1,2,3]</span><br><span class="line">&gt;&gt;&gt;help(a)                 # 查看列表 list 帮助信息</span><br><span class="line">……显示帮助信息……</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt;help(a.append)          # 显示list的append方法的帮助</span><br><span class="line">……显示帮助信息……</span><br></pre></td></tr></table></figure>

<h3 id="hex"><a href="#hex" class="headerlink" title="hex()"></a>hex()</h3><p>将一个指定数字(整数)转换为 16 进制数。</p>
<p>返回一个字符串，以 0x 开头。</p>
<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;hex(255)</span><br><span class="line">&#x27;0xff&#x27;</span><br><span class="line">&gt;&gt;&gt; hex(-42)</span><br><span class="line">&#x27;-0x2a&#x27;</span><br><span class="line">&gt;&gt;&gt; hex(12)</span><br><span class="line">&#x27;0xc&#x27;</span><br><span class="line">&gt;&gt;&gt; type(hex(12))</span><br><span class="line">&lt;class &#x27;str&#x27;&gt;      # 字符串</span><br></pre></td></tr></table></figure>

<h3 id="id"><a href="#id" class="headerlink" title="id()"></a>id()</h3><p>返回对象的唯一标识符，标识符是一个整数。</p>
<p>(也就是内存地址)</p>
<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;a = &#x27;runoob&#x27;</span><br><span class="line">&gt;&gt;&gt; id(a)</span><br><span class="line">4531887632</span><br><span class="line">&gt;&gt;&gt; b = 1</span><br><span class="line">&gt;&gt;&gt; id(b)</span><br><span class="line">140588731085608</span><br></pre></td></tr></table></figure>

<h3 id="input"><a href="#input" class="headerlink" title="input()"></a>input()</h3><p>接受一个标准输入数据，返回为 string 类型。</p>
<p>(就是电脑会要求你输入一个东西，和matlab里的某个很像)</p>
<p>example：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;a = input(&quot;input:&quot;)</span><br><span class="line">input:123                  # 输入整数</span><br><span class="line">&gt;&gt;&gt; type(a)</span><br><span class="line">&lt;class &#x27;str&#x27;&gt;              # 字符串</span><br><span class="line">&gt;&gt;&gt; a = input(&quot;input:&quot;)    </span><br><span class="line">input:runoob              # 正确，字符串表达式</span><br><span class="line">&gt;&gt;&gt; type(a)</span><br><span class="line">&lt;class &#x27;str&#x27;&gt;             # 字符串</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#输入三角形的三边长</span><br><span class="line">a,b,c = (input(&quot;请输入三角形三边的长：&quot;).split())</span><br><span class="line">a= int(a)</span><br><span class="line">b= int(b)</span><br><span class="line">c= int(c)</span><br><span class="line"></span><br><span class="line">#计算三角形的半周长p</span><br><span class="line">p=(a+b+c)/2</span><br><span class="line"></span><br><span class="line">#计算三角形的面积s</span><br><span class="line">s=(p*(p-a)*(p-b)*(p-c))**0.5</span><br><span class="line"></span><br><span class="line">#输出三角形的面积</span><br><span class="line">print(&quot;三角形面积为：&quot;,format(s,&#x27;.2f&#x27;))</span><br></pre></td></tr></table></figure>

<h3 id="int"><a href="#int" class="headerlink" title="int()"></a>int()</h3><p>将一个字符串或数字转换为整型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class int(x, base=10)</span><br><span class="line"></span><br><span class="line">x -- 字符串或数字。</span><br><span class="line">base -- 进制数，默认十进制。</span><br><span class="line"></span><br><span class="line">如果x是纯数字，就不能有base否则报错，int()的作用是取整</span><br><span class="line">如果x是str，base不存在时默认为10进制，base 存在时，视 x 为 base 类型数字，并将其转换为 10 进制数字。</span><br><span class="line">若 x 不符合 base 规则，则报错。</span><br></pre></td></tr></table></figure>

<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;int()               # 不传入参数时，得到结果0</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; int(3)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; int(3.6)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; int(&#x27;12&#x27;,16)        # 如果是带参数base的话，12要以字符串的形式进行输入，12 为 16进制</span><br><span class="line">18</span><br><span class="line">&gt;&gt;&gt; int(&#x27;0xa&#x27;,16)  </span><br><span class="line">10  </span><br><span class="line">&gt;&gt;&gt; int(&#x27;10&#x27;,8)  </span><br><span class="line">8</span><br><span class="line">&gt;&gt;&gt; int(2.5,10)</span><br><span class="line">#报错</span><br><span class="line">&gt;&gt;&gt; int(&quot;3.14&quot;,8)</span><br><span class="line">&gt;&gt;&gt; int(&quot;1.2&quot;)</span><br><span class="line">#均报错，str须为整数</span><br><span class="line">&gt;&gt;&gt; int(&quot;0xa&quot;,16)</span><br><span class="line">10</span><br><span class="line"># ≥16进制才会允许入参为a,b,c...</span><br><span class="line">&gt;&gt;&gt; int(&quot;b&quot;,8) #报错</span><br><span class="line">&gt;&gt;&gt; int(&quot;123&quot;,8)</span><br><span class="line">83</span><br><span class="line">#视123为8进制数字，对应的10进制为83</span><br></pre></td></tr></table></figure>

<h3 id="isinstance"><a href="#isinstance" class="headerlink" title="isinstance()"></a>isinstance()</h3><p>判断一个对象是否是一个已知的类型，类似 type()。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">isinstance() 与 type() 区别：</span><br><span class="line"></span><br><span class="line">	type() 不会认为子类是一种父类类型，不考虑继承关系。</span><br><span class="line"></span><br><span class="line">	isinstance() 会认为子类是一种父类类型，考虑继承关系。</span><br><span class="line"></span><br><span class="line">如果要判断两个类型是否相同推荐使用 isinstance()。</span><br><span class="line"></span><br><span class="line">class A:</span><br><span class="line">    pass</span><br><span class="line"> </span><br><span class="line">class B(A):</span><br><span class="line">    pass</span><br><span class="line"> </span><br><span class="line">isinstance(A(), A)    # returns True</span><br><span class="line">type(A()) == A        # returns True</span><br><span class="line">isinstance(B(), A)    # returns True</span><br><span class="line">type(B()) == A        # returns False</span><br></pre></td></tr></table></figure>

<p>example：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;a = 2</span><br><span class="line">&gt;&gt;&gt; isinstance (a,int)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance (a,str)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; isinstance (a,(str,int,list))    # 是元组中的一个返回 True</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<h3 id="issubclass"><a href="#issubclass" class="headerlink" title="issubclass()"></a>issubclass()</h3><p>判断参数 class 是否是类型参数 classinfo 的子类。</p>
<p>example：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A:</span><br><span class="line">    pass</span><br><span class="line">class B(A):</span><br><span class="line">    pass</span><br><span class="line">    </span><br><span class="line">print(issubclass(B,A))    # 返回 True</span><br></pre></td></tr></table></figure>

<h3 id="iter"><a href="#iter" class="headerlink" title="iter()"></a>iter()</h3><p>用来生成迭代器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iter(object[, sentinel])</span><br><span class="line"></span><br><span class="line">object -- 支持迭代的集合对象。</span><br><span class="line">sentinel -- 如果传递了第二个参数，则参数 object 必须是一个可调用的对象（如，函数），此时，iter 创建了一个迭代器对象，每次调用这个迭代器对象的__next__()方法时，都会调用 object。</span><br></pre></td></tr></table></figure>

<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;lst = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; for i in iter(lst):</span><br><span class="line">...     print(i)</span><br><span class="line">... </span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>有点集合比如说list，是不支持迭代的，这个时候就需要用iter()</p>
<h3 id="len"><a href="#len" class="headerlink" title="len()"></a>len()</h3><p>返回对象（字符、列表、元组等）长度或项目个数。</p>
<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;str = &quot;runoob&quot;</span><br><span class="line">&gt;&gt;&gt; len(str)             # 字符串长度</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; l = [1,2,3,4,5]</span><br><span class="line">&gt;&gt;&gt; len(l)               # 列表元素个数</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<h3 id="list"><a href="#list" class="headerlink" title="list()"></a>list()</h3><p>用于将元组或字符串转换为列表。</p>
<p>元组与列表是非常类似的，区别在于元组的元素值不能修改，元组是放在括号中，列表是放于方括号中。</p>
<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aTuple = (123, &#x27;Google&#x27;, &#x27;Runoob&#x27;, &#x27;Taobao&#x27;)</span><br><span class="line">list1 = list(aTuple)</span><br><span class="line">print (&quot;列表元素 : &quot;, list1)</span><br><span class="line"></span><br><span class="line">str=&quot;Hello World&quot;</span><br><span class="line">list2=list(str)</span><br><span class="line">print (&quot;列表元素 : &quot;, list2)</span><br><span class="line"></span><br><span class="line">列表元素 :  [123, &#x27;Google&#x27;, &#x27;Runoob&#x27;, &#x27;Taobao&#x27;]</span><br><span class="line">列表元素 :  [&#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27; &#x27;, &#x27;W&#x27;, &#x27;o&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;d&#x27;]</span><br></pre></td></tr></table></figure>

<h3 id="locals"><a href="#locals" class="headerlink" title="locals()"></a>locals()</h3><p>会以字典类型返回当前位置的全部局部变量。</p>
<p>对于函数, 方法, lambda 函式, 类, 以及实现了 <strong>call</strong> 方法的类实例, 它都返回 True。</p>
<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;def runoob(arg):    # 两个局部变量：arg、z</span><br><span class="line">...     z = 1</span><br><span class="line">...     print (locals())</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; runoob(4)</span><br><span class="line">&#123;&#x27;z&#x27;: 1, &#x27;arg&#x27;: 4&#125;      # 返回一个名字/值对的字典</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p>会根据提供的函数对指定序列做映射。</p>
<p>第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map(function, iterable, ...)</span><br></pre></td></tr></table></figure>

<p>跟filter的格式一样</p>
<p>返回一个迭代器。</p>
<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def square(x) :         # 计算平方数</span><br><span class="line">...     return x ** 2</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; map(square, [1,2,3,4,5])    # 计算列表各个元素的平方</span><br><span class="line">&lt;map object at 0x100d3d550&gt;     # 返回迭代器</span><br><span class="line">&gt;&gt;&gt; list(map(square, [1,2,3,4,5]))   # 使用 list() 转换为列表</span><br><span class="line">[1, 4, 9, 16, 25]</span><br><span class="line">&gt;&gt;&gt; list(map(lambda x: x ** 2, [1, 2, 3, 4, 5]))   # 使用 lambda 匿名函数</span><br><span class="line">[1, 4, 9, 16, 25]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="max"><a href="#max" class="headerlink" title="max()"></a>max()</h3><p>返回给定参数的最大值，参数可以为序列。</p>
<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">max(80, 100, 1000) :  1000</span><br><span class="line">max(-20, 100, 400) :  400</span><br><span class="line">max(-80, -20, -10) :  -10</span><br><span class="line">max(0, 100, -400) :  100</span><br></pre></td></tr></table></figure>

<h3 id="memoryview"><a href="#memoryview" class="headerlink" title="memoryview()"></a>memoryview()</h3><p>返回给定参数的内存查看对象(memory view)。</p>
<p>所谓内存查看对象，是指对支持缓冲区协议的数据进行包装，在不需要复制对象基础上允许Python代码访问。</p>
<p>example:</p>
<p>现在python3.x只能输入bytearray格式的对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;v = memoryview(bytearray(&quot;abcefg&quot;, &#x27;utf-8&#x27;))</span><br><span class="line">&gt;&gt;&gt; print(v[1])</span><br><span class="line">98</span><br><span class="line">&gt;&gt;&gt; print(v[-1])</span><br><span class="line">103</span><br><span class="line">&gt;&gt;&gt; print(v[1:4])</span><br><span class="line">&lt;memory at 0x10f543a08&gt;</span><br><span class="line">&gt;&gt;&gt; print(v[1:4].tobytes())</span><br><span class="line">b&#x27;bce&#x27;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="min"><a href="#min" class="headerlink" title="min()"></a>min()</h3><p>返回给定参数的最小值，参数可以为序列。</p>
<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">min(80, 100, 1000) :  80</span><br><span class="line">min(-20, 100, 400) :  -20</span><br><span class="line">min(-80, -20, -10) :  -80</span><br><span class="line">min(0, 100, -400) :  -400</span><br></pre></td></tr></table></figure>

<h3 id="next"><a href="#next" class="headerlink" title="next()"></a>next()</h3><p>返回迭代器的下一个项目。</p>
<p><strong>next()</strong> 函数要和生成迭代器的 <strong>iter()</strong> 函数一起使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">next(iterable[, default])</span><br><span class="line"></span><br><span class="line">iterable -- 可迭代对象</span><br><span class="line">default -- 可选，用于设置在没有下一个元素时返回该默认值，如果不设置，又没有下一个元素则会触发 StopIteration 异常。</span><br></pre></td></tr></table></figure>

<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 首先获得Iterator对象:</span><br><span class="line">it = iter([1, 2, 3, 4, 5])</span><br><span class="line"># 循环:</span><br><span class="line">while True:</span><br><span class="line">    try:</span><br><span class="line">        # 获得下一个值:</span><br><span class="line">        x = next(it)</span><br><span class="line">        print(x)</span><br><span class="line">    except StopIteration:</span><br><span class="line">        # 遇到StopIteration就退出循环</span><br><span class="line">        break</span><br></pre></td></tr></table></figure>

<h3 id="oct"><a href="#oct" class="headerlink" title="oct()"></a>oct()</h3><p>将一个整数转换成 8 进制字符串，8 进制以 <strong>0o</strong> 作为前缀表示。</p>
<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; oct(10)</span><br><span class="line">&#x27;0o12&#x27;</span><br><span class="line">&gt;&gt;&gt; oct(20)</span><br><span class="line">&#x27;0o24&#x27;</span><br><span class="line">&gt;&gt;&gt; oct(15)</span><br><span class="line">&#x27;0o17&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="open"><a href="#open" class="headerlink" title="open()"></a>open()</h3><p>用于打开一个文件，并返回文件对象，在对文件进行处理过程都需要使用到这个函数，如果该文件无法被打开，会抛出 OSError。</p>
<p>使用 open() 函数一定要保证关闭文件对象，即调用 close() 函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">open(file, mode=&#x27;r&#x27;, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)</span><br><span class="line"></span><br><span class="line">file: 必需，文件路径（相对或者绝对路径）。</span><br><span class="line">mode: 可选，文件打开模式</span><br><span class="line">buffering: 设置缓冲</span><br><span class="line">encoding: 一般使用utf8</span><br><span class="line">errors: 报错级别</span><br><span class="line">newline: 区分换行符</span><br><span class="line">closefd: 传入的file参数类型</span><br></pre></td></tr></table></figure>

<p>mode参数：</p>
<p><img src="image-20211106120750543.png" alt="image-20211106120750543"></p>
<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RUNOOB1  #test.txt的内容</span><br><span class="line">RUNOOB2</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;f = open(&#x27;test.txt&#x27;)</span><br><span class="line">&gt;&gt;&gt; f.read()</span><br><span class="line">&#x27;RUNOOB1\nRUNOOB2\n&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="ord"><a href="#ord" class="headerlink" title="ord()"></a>ord()</h3><p>是 chr() 函数（对于 8 位的 ASCII 字符串）的配对函数，它以一个字符串（Unicode 字符）作为参数，返回对应的 ASCII 数值，或者 Unicode 数值。</p>
<p>也就是对参数进行编码（encoding）</p>
<p>返回对应的十进制整数</p>
<p>example：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;ord(&#x27;a&#x27;)</span><br><span class="line">97</span><br><span class="line">&gt;&gt;&gt; ord(&#x27;€&#x27;)</span><br><span class="line">8364</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="pow"><a href="#pow" class="headerlink" title="pow()"></a>pow()</h3><p>返回 xy（x的y次方） 的值。</p>
<p>math模块的power：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import math</span><br><span class="line"></span><br><span class="line">math.pow( x, y )</span><br></pre></td></tr></table></figure>

<p>python内置的power：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pow(x, y[, z])</span><br><span class="line"></span><br><span class="line">函数是计算x的y次方，如果z在存在，则再对结果进行取模，其结果等效于pow(x,y) %z</span><br></pre></td></tr></table></figure>

<p>pow() 通过内置的方法直接调用，内置方法会把参数作为整型，而 math 模块则会把参数转换为 float。</p>
<p>example:</p>
<p>注意看两种调用的不同</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import math   # 导入 math 模块</span><br><span class="line"></span><br><span class="line">print (&quot;math.pow(100, 2) : &quot;, math.pow(100, 2))</span><br><span class="line"># 使用内置，查看输出结果区别</span><br><span class="line">print (&quot;pow(100, 2) : &quot;, pow(100, 2))</span><br><span class="line">print (&quot;math.pow(100, -2) : &quot;, math.pow(100, -2))</span><br><span class="line">print (&quot;math.pow(2, 4) : &quot;, math.pow(2, 4))</span><br><span class="line">print (&quot;math.pow(3, 0) : &quot;, math.pow(3, 0))</span><br><span class="line"></span><br><span class="line">math.pow(100, 2) :  10000.0</span><br><span class="line">pow(100, 2) :  10000</span><br><span class="line">math.pow(100, -2) :  0.0001</span><br><span class="line">math.pow(2, 4) :  16.0</span><br><span class="line">math.pow(3, 0) :  1.0</span><br></pre></td></tr></table></figure>

<h3 id="print"><a href="#print" class="headerlink" title="print()"></a>print()</h3><p>用于打印输出，最常见的一个函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(*objects, sep=&#x27; &#x27;, end=&#x27;\n&#x27;, file=sys.stdout, flush=False)</span><br><span class="line"></span><br><span class="line">objects -- 复数，表示可以一次输出多个对象。输出多个对象时，需要用 , 分隔。</span><br><span class="line">sep -- 用来间隔多个对象，默认值是一个空格。</span><br><span class="line">end -- 用来设定以什么结尾。默认值是换行符 \n，我们可以换成其他字符串。</span><br><span class="line">file -- 要写入的文件对象。</span><br><span class="line">flush -- 输出是否被缓存通常决定于 file，但如果 flush 关键字参数为 True，流会被强制刷新。</span><br></pre></td></tr></table></figure>

<p>example：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;print(1)  </span><br><span class="line">1  </span><br><span class="line">&gt;&gt;&gt; print(&quot;Hello World&quot;)  </span><br><span class="line">Hello World  </span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; a = 1</span><br><span class="line">&gt;&gt;&gt; b = &#x27;runoob&#x27;</span><br><span class="line">&gt;&gt;&gt; print(a,b)</span><br><span class="line">1 runoob</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; print(&quot;aaa&quot;&quot;bbb&quot;)</span><br><span class="line">aaabbb</span><br><span class="line">&gt;&gt;&gt; print(&quot;aaa&quot;,&quot;bbb&quot;)</span><br><span class="line">aaa bbb</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; print(&quot;www&quot;,&quot;runoob&quot;,&quot;com&quot;,sep=&quot;.&quot;)  # 设置间隔符</span><br><span class="line">www.runoob.com</span><br></pre></td></tr></table></figure>

<p>Loading效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">print(&quot;---RUNOOB EXAMPLE ： Loading 效果---&quot;)</span><br><span class="line"></span><br><span class="line">print(&quot;Loading&quot;,end = &quot;&quot;)</span><br><span class="line">for i in range(20):</span><br><span class="line">    print(&quot;.&quot;,end = &#x27;&#x27;,flush = True)</span><br><span class="line">    time.sleep(0.5)</span><br></pre></td></tr></table></figure>

<h3 id="property"><a href="#property" class="headerlink" title="property()"></a>property()</h3><p>在新式类中返回属性值。</p>
<p>其实就是给某个属性值匹配几个函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class property([fget[, fset[, fdel[, doc]]]])</span><br><span class="line"></span><br><span class="line">fget -- 获取属性值的函数</span><br><span class="line">fset -- 设置属性值的函数</span><br><span class="line">fdel -- 删除属性值函数</span><br><span class="line">doc -- 属性描述信息</span><br></pre></td></tr></table></figure>

<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class C(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self._x = None</span><br><span class="line"> </span><br><span class="line">    def getx(self):</span><br><span class="line">        return self._x</span><br><span class="line"> </span><br><span class="line">    def setx(self, value):</span><br><span class="line">        self._x = value</span><br><span class="line"> </span><br><span class="line">    def delx(self):</span><br><span class="line">        del self._x</span><br><span class="line"> </span><br><span class="line">    x = property(getx, setx, delx, &quot;I&#x27;m the &#x27;x&#x27; property.&quot;)</span><br></pre></td></tr></table></figure>

<p>这里就是给x匹配了上述几个有相对应功能的函数。</p>
<p>如果 <em>c</em> 是 <em>C</em> 的实例化, c.x 将触发 getter,c.x = value 将触发 setter ， del c.x 触发 deleter。</p>
<p>如果给定 doc 参数，其将成为这个属性值的 docstring，否则 property 函数就会复制 fget 函数的 docstring（如果有的话）。</p>
<p>将 property 函数用作装饰器可以很方便的创建只读属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class C(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self._x = None</span><br><span class="line"> </span><br><span class="line">    @property</span><br><span class="line">    def x(self):</span><br><span class="line">        &quot;&quot;&quot;I&#x27;m the &#x27;x&#x27; property.&quot;&quot;&quot;</span><br><span class="line">        return self._x</span><br><span class="line"> </span><br><span class="line">    @x.setter</span><br><span class="line">    def x(self, value):</span><br><span class="line">        self._x = value</span><br><span class="line"> </span><br><span class="line">    @x.deleter</span><br><span class="line">    def x(self):</span><br><span class="line">        del self._x</span><br></pre></td></tr></table></figure>

<h3 id="range"><a href="#range" class="headerlink" title="range()"></a>range()</h3><p>返回的是一个可迭代对象（类型是对象），而不是列表类型， 所以打印的时候不会打印列表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">range(stop)</span><br><span class="line">range(start, stop[, step])</span><br><span class="line"></span><br><span class="line">start: 计数从 start 开始。默认是从 0 开始。例如range（5）等价于range（0， 5）;</span><br><span class="line">stop: 计数到 stop 结束，但不包括 stop。例如：range（0， 5） 是[0, 1, 2, 3, 4]没有5</span><br><span class="line">step：步长，默认为1。例如：range（0， 5） 等价于 range(0, 5, 1)</span><br></pre></td></tr></table></figure>

<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;range(5)</span><br><span class="line">range(0, 5)</span><br><span class="line">&gt;&gt;&gt; for i in range(5):</span><br><span class="line">...     print(i)</span><br><span class="line">... </span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; list(range(5))</span><br><span class="line">[0, 1, 2, 3, 4]</span><br><span class="line">&gt;&gt;&gt; list(range(0))</span><br><span class="line">[]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;list(range(0, 30, 5))</span><br><span class="line">[0, 5, 10, 15, 20, 25]</span><br><span class="line">&gt;&gt;&gt; list(range(0, 10, 2))</span><br><span class="line">[0, 2, 4, 6, 8]</span><br><span class="line">&gt;&gt;&gt; list(range(0, -10, -1))</span><br><span class="line">[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]</span><br><span class="line">&gt;&gt;&gt; list(range(1, 0))</span><br><span class="line">[]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="repr"><a href="#repr" class="headerlink" title="repr()"></a>repr()</h3><p>将对象转化为供解释器读取的形式。</p>
<p>返回一个对象的 string 格式。(就是编码encoding) 和ascii()一样</p>
<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;s = &#x27;RUNOOB&#x27;</span><br><span class="line">&gt;&gt;&gt; repr(s)</span><br><span class="line">&quot;&#x27;RUNOOB&#x27;&quot;</span><br><span class="line">&gt;&gt;&gt; dict = &#123;&#x27;runoob&#x27;: &#x27;runoob.com&#x27;, &#x27;google&#x27;: &#x27;google.com&#x27;&#125;;</span><br><span class="line">&gt;&gt;&gt; repr(dict)</span><br><span class="line">&quot;&#123;&#x27;google&#x27;: &#x27;google.com&#x27;, &#x27;runoob&#x27;: &#x27;runoob.com&#x27;&#125;&quot;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="reversed"><a href="#reversed" class="headerlink" title="reversed()"></a>reversed()</h3><p>返回一个反转的迭代器。</p>
<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 字符串</span><br><span class="line">seqString = &#x27;Runoob&#x27;</span><br><span class="line">print(list(reversed(seqString)))</span><br><span class="line"> </span><br><span class="line"># 元组</span><br><span class="line">seqTuple = (&#x27;R&#x27;, &#x27;u&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;o&#x27;, &#x27;b&#x27;)</span><br><span class="line">print(list(reversed(seqTuple)))</span><br><span class="line"> </span><br><span class="line"># range</span><br><span class="line">seqRange = range(5, 9)</span><br><span class="line">print(list(reversed(seqRange)))</span><br><span class="line"> </span><br><span class="line"># 列表</span><br><span class="line">seqList = [1, 2, 4, 3, 5]</span><br><span class="line">print(list(reversed(seqList)))</span><br><span class="line"></span><br><span class="line">#输出结果：</span><br><span class="line">[&#x27;b&#x27;, &#x27;o&#x27;, &#x27;o&#x27;, &#x27;n&#x27;, &#x27;u&#x27;, &#x27;R&#x27;]</span><br><span class="line">[&#x27;b&#x27;, &#x27;o&#x27;, &#x27;o&#x27;, &#x27;n&#x27;, &#x27;u&#x27;, &#x27;R&#x27;]</span><br><span class="line">[8, 7, 6, 5]</span><br><span class="line">[5, 3, 4, 2, 1]</span><br></pre></td></tr></table></figure>

<h3 id="round"><a href="#round" class="headerlink" title="round()"></a>round()</h3><p>返回浮点数 x 的四舍五入值，准确的说保留值将保留到离上一位更近的一端（四舍六入）。</p>
<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">round(70.23456) :  70</span><br><span class="line">round(56.659,1) :  56.7</span><br><span class="line">round(80.264, 2) :  80.26</span><br><span class="line">round(100.000056, 3) :  100.0</span><br><span class="line">round(-100.000056, 3) :  -100.0</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; round(2.675, 2) </span><br><span class="line">2.67</span><br></pre></td></tr></table></figure>

<p><strong>按我们的想法返回结果应该是 2.68，可结果却是 2.67，为什么？</strong></p>
<p>这跟浮点数的精度有关。我们知道在机器中浮点数不一定能精确表达，因为换算成一串 1 和 0 后可能是无限位数的，机器已经做出了截断处理。那么在机器中保存的2.675这个数字就比实际数字要小那么一点点。这一点点就导致了它离 2.67 要更近一点点，所以保留两位小数时就近似到了 2.67</p>
<p>（cu的math3230有讲）</p>
<h3 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h3><p>创建一个无序不重复元素集，可进行关系测试，删除重复数据，还可以计算交集、差集、并集等。</p>
<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; x = set(&#x27;eleven&#x27;)</span><br><span class="line">&gt;&gt;&gt; y = set(&#x27;twelve&#x27;)</span><br><span class="line">&gt;&gt;&gt; x,y</span><br><span class="line">(&#123;&#x27;l&#x27;, &#x27;e&#x27;, &#x27;n&#x27;, &#x27;v&#x27;&#125;, &#123;&#x27;e&#x27;, &#x27;v&#x27;, &#x27;l&#x27;, &#x27;t&#x27;, &#x27;w&#x27;&#125;)</span><br><span class="line">&gt;&gt;&gt; x &amp; y  #交集</span><br><span class="line">&#123;&#x27;l&#x27;, &#x27;e&#x27;, &#x27;v&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; x | y  #并集</span><br><span class="line">&#123;&#x27;e&#x27;, &#x27;v&#x27;, &#x27;n&#x27;, &#x27;l&#x27;, &#x27;t&#x27;, &#x27;w&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; x - y  #差集</span><br><span class="line">&#123;&#x27;n&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; y -x   #差集</span><br><span class="line">&#123;&#x27;t&#x27;, &#x27;w&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; x ^ y  #补集</span><br><span class="line">&#123;&#x27;t&#x27;, &#x27;n&#x27;, &#x27;w&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; y ^ x  #补集</span><br><span class="line">&#123;&#x27;w&#x27;, &#x27;n&#x27;, &#x27;t&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; </span><br></pre></td></tr></table></figure>

<h3 id="setattr"><a href="#setattr" class="headerlink" title="setattr()"></a>setattr()</h3><p>对应函数getattr()，用于设置属性值，该属性不一定是存在的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setattr(object, name, value)</span><br></pre></td></tr></table></figure>

<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#对已存在的属性：</span><br><span class="line">&gt;&gt;&gt;class A(object):</span><br><span class="line">...     bar = 1</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; a = A()</span><br><span class="line">&gt;&gt;&gt; getattr(a, &#x27;bar&#x27;)          # 获取属性 bar 值</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; setattr(a, &#x27;bar&#x27;, 5)       # 设置属性 bar 值</span><br><span class="line">&gt;&gt;&gt; a.bar</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">#对不存在的会创建一个新的对象属性，并对属性赋值：</span><br><span class="line">&gt;&gt;&gt;class A():</span><br><span class="line">...     name = &quot;runoob&quot;</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; a = A()</span><br><span class="line">&gt;&gt;&gt; setattr(a, &quot;age&quot;, 28)</span><br><span class="line">&gt;&gt;&gt; print(a.age)</span><br><span class="line">28</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h3><p>实现切片对象，主要用在切片操作函数里的参数传递。</p>
<p>(设置一个切片方法)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class slice(stop)</span><br><span class="line">class slice(start, stop[, step])</span><br></pre></td></tr></table></figure>

<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;myslice = slice(5)    # 设置截取5个元素的切片</span><br><span class="line">&gt;&gt;&gt; myslice</span><br><span class="line">slice(None, 5, None)</span><br><span class="line">&gt;&gt;&gt; arr = range(10)</span><br><span class="line">&gt;&gt;&gt; arr</span><br><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">&gt;&gt;&gt; arr[myslice]         # 截取 5 个元素</span><br><span class="line">[0, 1, 2, 3, 4]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted()"></a>sorted()</h3><p>对所有可迭代的对象进行排序操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sort 与 sorted 区别：</span><br><span class="line"></span><br><span class="line">sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。</span><br><span class="line"></span><br><span class="line">list 的 sort 方法返回的是对已经存在的列表进行操作，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sorted(iterable, key=None, reverse=False)  </span><br><span class="line"></span><br><span class="line">iterable -- 可迭代对象。</span><br><span class="line">key -- 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。</span><br><span class="line">reverse -- 排序规则，reverse = True 降序 ， reverse = False 升序（默认）。</span><br></pre></td></tr></table></figure>

<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted([5, 2, 3, 1, 4])</span><br><span class="line">[1, 2, 3, 4, 5]                      # 默认为升序</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; sorted(&#123;1: &#x27;D&#x27;, 2: &#x27;B&#x27;, 3: &#x27;B&#x27;, 4: &#x27;E&#x27;, 5: &#x27;A&#x27;&#125;)</span><br><span class="line">[1, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">#利用key进行倒序排序</span><br><span class="line">&gt;&gt;&gt; example_list = [5, 0, 6, 1, 2, 7, 3, 4]</span><br><span class="line">&gt;&gt;&gt; result_list = sorted(example_list, key=lambda x: x*-1)</span><br><span class="line">&gt;&gt;&gt; print(result_list)</span><br><span class="line">[7, 6, 5, 4, 3, 2, 1, 0]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"></span><br><span class="line">#也可以通过传入第三个参数 reverse=True：</span><br><span class="line">&gt;&gt;&gt; example_list = [5, 0, 6, 1, 2, 7, 3, 4]</span><br><span class="line">&gt;&gt;&gt; sorted(example_list, reverse=True)</span><br><span class="line">[7, 6, 5, 4, 3, 2, 1, 0]</span><br></pre></td></tr></table></figure>

<h3 id="staticmethod"><a href="#staticmethod" class="headerlink" title="staticmethod()"></a>staticmethod()</h3><p>返回函数的静态方法。</p>
<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class C(object):</span><br><span class="line">    @staticmethod</span><br><span class="line">    def f():</span><br><span class="line">        print(&#x27;runoob&#x27;);</span><br><span class="line"> </span><br><span class="line">C.f();          # 静态方法无需实例化</span><br><span class="line">cobj = C()</span><br><span class="line">cobj.f()        # 也可以实例化后调用</span><br><span class="line"></span><br><span class="line">runoob</span><br><span class="line">runoob</span><br></pre></td></tr></table></figure>

<p>（和classmethod()差不多，只不过这个也可以实例化后调用）</p>
<p>参数要求是 Callable, 也就是说 Class 也是可以的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class C1(object):</span><br><span class="line">    @staticmethod</span><br><span class="line">    class C2(object):</span><br><span class="line">        def __init__(self, val = 1):</span><br><span class="line">            self.val = val</span><br><span class="line">        def shout(self):</span><br><span class="line">            print(&quot;Python世界第%d!&quot;%self.val)</span><br><span class="line">tmp = C1.C2(0)</span><br><span class="line">print(type(tmp))    # 输出 : &lt;class &#x27;__main__.C1.C2&#x27;&gt;</span><br><span class="line">tmp.shout()         # 输出 : Python世界第0!</span><br></pre></td></tr></table></figure>

<h3 id="str"><a href="#str" class="headerlink" title="str()"></a>str()</h3><p>将对象转化为适于人阅读的形式。</p>
<p>返回一个对象的string格式。</p>
<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;s = &#x27;RUNOOB&#x27;</span><br><span class="line">&gt;&gt;&gt; str(s)</span><br><span class="line">&#x27;RUNOOB&#x27;</span><br><span class="line">&gt;&gt;&gt; dict = &#123;&#x27;runoob&#x27;: &#x27;runoob.com&#x27;, &#x27;google&#x27;: &#x27;google.com&#x27;&#125;;</span><br><span class="line">&gt;&gt;&gt; str(dict)</span><br><span class="line">&quot;&#123;&#x27;google&#x27;: &#x27;google.com&#x27;, &#x27;runoob&#x27;: &#x27;runoob.com&#x27;&#125;&quot;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>和repr()好像没什么不一样</p>
<h3 id="sum"><a href="#sum" class="headerlink" title="sum()"></a>sum()</h3><p>对序列进行求和计算。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sum(iterable[, start])</span><br><span class="line"></span><br><span class="line">iterable -- 可迭代对象，如：列表、元组、集合。</span><br><span class="line">start -- 指定相加的参数，如果没有设置这个值，默认为0。</span><br></pre></td></tr></table></figure>

<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;sum([0,1,2])  </span><br><span class="line">3  </span><br><span class="line">&gt;&gt;&gt; sum((2, 3, 4), 1)        # 元组计算总和后再加 1</span><br><span class="line">10</span><br><span class="line">&gt;&gt;&gt; sum([0,1,2,3,4], 2)      # 列表计算总和后再加 2</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<h3 id="super"><a href="#super" class="headerlink" title="super()"></a>super()</h3><p>用于调用父类(超类)的一个方法。</p>
<p><strong>super()</strong> 是用来解决多重继承问题的，直接用类名调用父类方法在使用单继承的时候没问题，但是如果使用多继承，会涉及到查找顺序（MRO）、重复调用（钻石继承）等种种问题。</p>
<p>MRO 就是类的方法解析顺序表, 其实也就是继承父类方法时的顺序表。</p>
<p>继承就是能调用父类的方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">super(type[, object-or-type])</span><br><span class="line"></span><br><span class="line">type -- 类。</span><br><span class="line">object-or-type -- 类，一般是 self</span><br></pre></td></tr></table></figure>

<p>Python3.x 和 Python2.x 的一个区别是: Python 3 可以使用直接使用 <strong>super().xxx</strong> 代替 <strong>super(Class, self).xxx</strong> </p>
<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A:</span><br><span class="line">     def add(self, x):</span><br><span class="line">         y = x+1</span><br><span class="line">         print(y)</span><br><span class="line">class B(A):</span><br><span class="line">    def add(self, x):</span><br><span class="line">        super().add(x)</span><br><span class="line">b = B()</span><br><span class="line">b.add(2)  # 3</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class FooParent(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.parent = &#x27;I\&#x27;m the parent.&#x27;</span><br><span class="line">        print (&#x27;Parent&#x27;)</span><br><span class="line">    </span><br><span class="line">    def bar(self,message):</span><br><span class="line">        print (&quot;%s from Parent&quot; % message)</span><br><span class="line"> </span><br><span class="line">class FooChild(FooParent):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        # super(FooChild,self) 首先找到 FooChild 的父类（就是类 FooParent），然后把类 FooChild 的对象转换为类 FooParent 的对象</span><br><span class="line">        super(FooChild,self).__init__()    </span><br><span class="line">        print (&#x27;Child&#x27;)</span><br><span class="line">        </span><br><span class="line">    def bar(self,message):</span><br><span class="line">        super(FooChild, self).bar(message)</span><br><span class="line">        print (&#x27;Child bar fuction&#x27;)</span><br><span class="line">        print (self.parent)</span><br><span class="line"> </span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    fooChild = FooChild()</span><br><span class="line">    fooChild.bar(&#x27;HelloWorld&#x27;)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">#结果：</span><br><span class="line">Parent</span><br><span class="line">Child</span><br><span class="line">HelloWorld from Parent</span><br><span class="line">Child bar fuction</span><br><span class="line">I&#x27;m the parent.</span><br></pre></td></tr></table></figure>

<h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple()"></a>tuple()</h3><p>将可迭代系列（如列表）转换为元组。</p>
<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;list1= [&#x27;Google&#x27;, &#x27;Taobao&#x27;, &#x27;Runoob&#x27;, &#x27;Baidu&#x27;]</span><br><span class="line">&gt;&gt;&gt; tuple1=tuple(list1)</span><br><span class="line">&gt;&gt;&gt; tuple1</span><br><span class="line">(&#x27;Google&#x27;, &#x27;Taobao&#x27;, &#x27;Runoob&#x27;, &#x27;Baidu&#x27;)</span><br></pre></td></tr></table></figure>

<h3 id="type"><a href="#type" class="headerlink" title="type()"></a>type()</h3><p>如果你只有第一个参数则返回对象的类型，三个参数返回新的类型对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">isinstance() 与 type() 区别：</span><br><span class="line"></span><br><span class="line">	type() 不会认为子类是一种父类类型，不考虑继承关系。</span><br><span class="line"></span><br><span class="line">	isinstance() 会认为子类是一种父类类型，考虑继承关系。</span><br><span class="line"></span><br><span class="line">如果要判断两个类型是否相同推荐使用 isinstance()。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type(object)</span><br><span class="line">type(name, bases, dict)</span><br><span class="line"></span><br><span class="line">name -- 类的名称。</span><br><span class="line">bases -- 基类的元组。</span><br><span class="line">dict -- 字典，类内定义的命名空间变量。</span><br></pre></td></tr></table></figure>

<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 一个参数实例</span><br><span class="line">&gt;&gt;&gt; type(1)</span><br><span class="line">&lt;type &#x27;int&#x27;&gt;</span><br><span class="line">&gt;&gt;&gt; type(&#x27;runoob&#x27;)</span><br><span class="line">&lt;type &#x27;str&#x27;&gt;</span><br><span class="line">&gt;&gt;&gt; type([2])</span><br><span class="line">&lt;type &#x27;list&#x27;&gt;</span><br><span class="line">&gt;&gt;&gt; type(&#123;0:&#x27;zero&#x27;&#125;)</span><br><span class="line">&lt;type &#x27;dict&#x27;&gt;</span><br><span class="line">&gt;&gt;&gt; x = 1          </span><br><span class="line">&gt;&gt;&gt; type( x ) == int    # 判断类型是否相等</span><br><span class="line">True</span><br><span class="line"> </span><br><span class="line"># 三个参数</span><br><span class="line">&gt;&gt;&gt; class X(object):</span><br><span class="line">...     a = 1</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; X = type(&#x27;X&#x27;, (object,), dict(a=1))  # 产生一个新的类型 X</span><br><span class="line">&gt;&gt;&gt; X</span><br><span class="line">&lt;class &#x27;__main__.X&#x27;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="vars"><a href="#vars" class="headerlink" title="vars()"></a>vars()</h3><p>返回对象object的属性和属性值的字典对象。</p>
<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;print(vars())</span><br><span class="line">&#123;&#x27;__builtins__&#x27;: &lt;module &#x27;__builtin__&#x27; (built-in)&gt;, &#x27;__name__&#x27;: &#x27;__main__&#x27;, &#x27;__doc__&#x27;: None, &#x27;__package__&#x27;: None&#125;</span><br><span class="line">&gt;&gt;&gt; class Runoob:</span><br><span class="line">...     a = 1</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; print(vars(Runoob))</span><br><span class="line">&#123;&#x27;a&#x27;: 1, &#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;__doc__&#x27;: None&#125;</span><br><span class="line">&gt;&gt;&gt; runoob = Runoob()</span><br><span class="line">&gt;&gt;&gt; print(vars(runoob))</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="zip"><a href="#zip" class="headerlink" title="zip()"></a>zip()</h3><p>用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的对象，这样做的好处是节约了不少的内存。</p>
<p>我们可以使用 list() 转换来输出列表。</p>
<p>如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 ***** 号操作符，可以将元组解压为列表</p>
<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;a = [1,2,3]</span><br><span class="line">&gt;&gt;&gt; b = [4,5,6]</span><br><span class="line">&gt;&gt;&gt; c = [4,5,6,7,8]</span><br><span class="line">&gt;&gt;&gt; zipped = zip(a,b)     # 返回一个对象</span><br><span class="line">&gt;&gt;&gt; zipped</span><br><span class="line">&lt;zip object at 0x103abc288&gt;</span><br><span class="line">&gt;&gt;&gt; list(zipped)  # list() 转换为列表</span><br><span class="line">[(1, 4), (2, 5), (3, 6)]</span><br><span class="line">&gt;&gt;&gt; list(zip(a,c))              # 元素个数与最短的列表一致</span><br><span class="line">[(1, 4), (2, 5), (3, 6)]</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; a1, a2 = zip(*zip(a,b))          # 与 zip 相反，zip(*) 可理解为解压，返回二维矩阵式</span><br><span class="line">&gt;&gt;&gt; list(a1)</span><br><span class="line">[1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; list(a2)</span><br><span class="line">[4, 5, 6]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="import"><a href="#import" class="headerlink" title="import()"></a><strong>import</strong>()</h3><p>用于动态加载类和函数 。</p>
<p>如果一个模块经常变化就可以使用 <strong>import</strong>() 来动态载入。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__import__(name[, globals[, locals[, fromlist[, level]]]])</span><br><span class="line"></span><br><span class="line">name -- 模块名</span><br><span class="line">返回元组列表。</span><br></pre></td></tr></table></figure>

<p>example:</p>
<p>a.py 文件代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import os  </span><br><span class="line"> </span><br><span class="line">print (&#x27;在 a.py 文件中 %s&#x27; % id(os))</span><br></pre></td></tr></table></figure>

<p>test.py 文件代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import sys  </span><br><span class="line">__import__(&#x27;a&#x27;)        # 导入 a.py 模块</span><br></pre></td></tr></table></figure>

<p>执行 test.py 文件，输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在 a.py 文件中 4394716136</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python内置函数</tag>
      </tags>
  </entry>
  <entry>
    <title>First Blog</title>
    <url>/2021/10/15/First-Blog/</url>
    <content><![CDATA[<p>今天突发奇想心血来潮在这香港入秋(?)的夜里弄好了一个personal blog</p>
<p>期间怎么买域名 怎么设置github就不足为道了哈哈哈</p>
<span id="more"></span>

<p>现在很多功能还没实现 点进去就是404 就等着之后更新了吧</p>
<p>其实早就想找个地方写点自己的东西了 毕竟我感觉我平时的思考还蛮多的 又没有什么好地方写东西 就想着这样建立一个网站是最好的了 </p>
<p>至于之后会更新什么  感觉一切都有可能吧！</p>
<p>嘿嘿 是不是很cool？</p>
<p>###更新日志</p>
<p>10-15 增加评论和分享功能<br>10-16 增加看板娘，增加日夜模式交换按钮，增加留言板匿名</p>
]]></content>
  </entry>
  <entry>
    <title>我为什么不干正经事</title>
    <url>/2021/10/16/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%B9%B2%E6%AD%A3%E7%BB%8F%E4%BA%8B/</url>
    <content><![CDATA[<p>前几天我在知乎上载了一个 <a href="https://www.zhihu.com/pin/1429619175618273280">“想法”</a>, 原因就是我废寝忘食地搞了两天代码后发现： 代码是搞定了，但它好像没多大作用。 一边被催进度说要创新，一边发现自己刚解决的这个事引出了后边的一大堆事。 这可不让人糟心吗 比剥核桃核桃壳刺指甲缝还糟心</p>
<span id="more"></span>

<p>正好那天LOL手游出了，我就打蛇随棍上，报复性地刷了两天手游 我一边期待有人能和我一起玩，又不知道为什么没有去玩端游 在这上边还能和老黄一起玩玩。 好呗，没人玩我就也不玩了，没兴致了，虽然现在还在领领礼包，我也不想玩了 然后我又在steam上找 找了一个之前没通关的单机 玩了老半天通关了。 然后又去叙利亚小号那买了个超凡双生，就是做底特律变人的那个游戏商，虽然中间有点芦花（但说实话美国佬在这里边芦自己我感觉更狠哈哈哈），但故事挺不错的。 我感觉这种游戏就跟看电影一样。 之前不知道在哪看到的， 这种要做选择的，云通关就没意思了，的确是这样，我现在就很后悔高中的时候把底特律变人云了。 玩超凡双生的时候，因为不能读档，我确实感觉到了玩其他单机体会不到的东西。外加他本身就是营造这种氛围，我玩的时候都很投入。</p>
<p>好吧，游戏玩完了，但我还不想干正经的，我就在知乎上看呀看，然后看到我最近收藏的建博客。 好啊， 郎有情女有意， 一不做而不休，我就开始肝自己搭一个博客。有一说一，域名确实不贵，我这个才六十多一年。 重要的是，我真的搭成了， 而且还搞了很多有意思的东西。 我感觉。。。这真的算实现小时候的一种梦想。 毕竟我小时候不仅想过自己做游戏，也想过自己做个网站。 哎，理工男的雏形嘛，总有点奇奇怪怪的想法。我做的这个虽然没稚晖君那么牛，但我成就感也挺高的。不管有没有人访问，我自己自由地写点东西反正没问题。十月十五号的晚上，不到一天的时间，我这个是正式搭完了。期间我还给几个学校的老师套了磁，然后距今还没人回我，然后我发现也只有一个老师下载了我的CV。</p>
<p>卷起来了卷起来了。 我确实挺慌的。 但只是内心深处很慌。 我总是很淡定。 我记得前两年的暑假， 我开车带着两个好兄弟在山路上飙车，就是那种一边是山壁一边是悬崖的山路。 在一段下坡的时候，兄弟们跟我说让我开慢点，我也觉得要慢点，于是我就踩下去了。 哈哈，结果踩的是油门。 那一刻，我的脑子清楚地意识到我踩错了，因为视觉包括触觉都告诉了我这一点，但很神奇的是，我没有慌，手臂上的肌肉很快被控制了：我在掉下悬崖之前打了个大方向盘。这件事我至今没跟我父母讲，一是不想让他们担心，二是我真的潜意识里觉得，再来一遍我还是死不了。虽然后怕还是会后怕哈哈哈。</p>
<p>现在我就好像也在山路上飙车，一边是深不见底的悬崖，方向盘掌控在我手上。只不过这一次车后座上没有兄弟，我也不是单靠一瞬间的反应就能保证安全度过。更像是我开着一辆安装了喷射器的独轮车，然后在九曲十八弯的独木桥上行驶着。而且因为我太过懈怠没注意过桥时间，这桥在一定时间内就要塌了。一路上经历的奇奇怪怪的东西不知道今后会给我什么帮助，但至少这次它们是真帮不上忙。祝我好运吧！</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>thinking</tag>
      </tags>
  </entry>
  <entry>
    <title>终于像样了！</title>
    <url>/2021/10/15/%E7%BB%88%E4%BA%8E%E5%83%8F%E6%A0%B7%E4%BA%86%EF%BC%81/</url>
    <content><![CDATA[<p>搞了好久 把评论功能和分享功能弄上去了哈哈哈哈</p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
</search>
